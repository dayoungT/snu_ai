<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¢Œí‘œí‰ë©´ ì§€ë¢° ê²Œì„</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header-title {
            font-size: 32px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .header-title::before {
            content: 'ğŸ’£';
            font-size: 36px;
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .header-author {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            font-weight: normal;
            margin-top: 5px;
        }
        .stage-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
        }
        .stage-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .stage-item.active {
            background: rgba(255,255,255,0.9);
            color: #667eea;
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .stage-item.completed {
            background: rgba(40, 167, 69, 0.8);
            color: white;
        }
        .stage-connector {
            width: 30px;
            height: 2px;
            background: rgba(255,255,255,0.5);
        }
        .stage-connector.completed {
            background: rgba(255,255,255,0.9);
        }
        .mines-preview {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }
        .mine-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transition: all 0.3s;
            position: relative;
        }
        .mine-icon.found {
            background: rgba(40, 167, 69, 0.8);
            transform: scale(1.2);
        }
        .mine-icon.found::after {
            content: 'âœ“';
            position: absolute;
            color: white;
            font-size: 20px;
            font-weight: bold;
        }
        .input-error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
            padding: 5px;
            display: none;
        }
        .input-error.show {
            display: block;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 20px auto;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }
        .panel {
            flex: 0 0 300px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .canvas-container {
            flex: 1;
            min-width: 500px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        .log-panel {
            flex: 0 0 300px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        #svgCanvas {
            width: 100%;
            max-width: 640px;
            height: 640px;
            margin: 0 auto;
            border: 2px solid #ddd;
            background: #fff;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #667eea;
            color: white;
            transition: all 0.3s;
        }
        #submitBtn {
            min-width: 60px;
            padding: 8px 20px;
            font-size: 14px;
        }
        button:hover { background: #5568d3; transform: translateY(-2px); }
        button:active { transform: translateY(0); }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .info-item {
            padding: 8px;
            background: #f5f5f5;
            border-radius: 5px;
            font-size: 14px;
        }
        .info-item strong { color: #667eea; }
        .input-group {
            display: flex;
            gap: 10px;
        }
        input[type="text"] {
            flex: 1;
            padding: 10px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        .accordion {
            margin-top: 10px;
        }
        .accordion-header {
            background: #f0f0f0;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            user-select: none;
        }
        .accordion-content {
            display: none;
            padding: 10px;
            background: #fafafa;
            border-radius: 5px;
            margin-top: 5px;
            font-size: 13px;
            line-height: 1.6;
        }
        .accordion-content.show { display: block; }
        .log-area {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            max-height: 500px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
            flex: 1;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #667eea;
            padding-left: 10px;
        }
        .log-entry.success { border-color: #28a745; }
        .log-entry.fail { border-color: #dc3545; }
        .log-entry.error { border-color: #ffc107; }
        .hint-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: #fff;
            padding: 25px 35px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 3px solid #667eea;
            z-index: 1000;
            animation: popupAppear 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            color: #333;
            font-weight: bold;
            max-width: 400px;
            text-align: center;
        }
        @keyframes popupAppear {
            0% { 
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        .hint-popup::before {
            content: 'ğŸ’¡';
            font-size: 40px;
            display: block;
            margin-bottom: 10px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .hint-popup-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: #f5f5f5;
            border: none;
            color: #333;
            font-size: 24px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .hint-popup-close:hover {
            background: #667eea;
            color: #fff;
            transform: rotate(90deg);
        }
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .toggle-switch {
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active { background: #28a745; }
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        .toggle-switch.active::after { left: 28px; }
        .explosion {
            animation: explode 0.6s ease-out;
            animation-fill-mode: forwards;
            transform-origin: center;
        }
        @keyframes explode {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        #marks {
            pointer-events: none;
        }
        #marks > * {
            pointer-events: auto;
        }
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .intro-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: #fff;
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
            border: 3px solid #667eea;
            z-index: 1500;
            animation: popupAppear 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            color: #333;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .intro-popup h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 24px;
            text-align: center;
        }
        .intro-popup h2::before {
            content: 'ğŸ’£';
            font-size: 28px;
            margin-right: 10px;
        }
        .intro-popup-content {
            text-align: left;
            line-height: 1.8;
            font-size: 15px;
        }
        .intro-popup-content strong {
            color: #667eea;
        }
        .intro-popup-content ul {
            margin: 10px 0;
            padding-left: 25px;
        }
        .intro-popup-content li {
            margin: 8px 0;
        }
        .intro-popup-content code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #667eea;
        }
        .intro-popup-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #f5f5f5;
            border: none;
            color: #333;
            font-size: 28px;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .intro-popup-close:hover {
            background: #667eea;
            color: #fff;
            transform: rotate(90deg);
        }
        .game-over {
            position: relative;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }
        .game-over h2 { 
            color: #667eea; 
            margin-bottom: 20px; 
            font-size: 28px;
            text-align: center;
        }
        .game-over p { 
            margin: 15px 0; 
            font-size: 16px;
            color: #333;
        }
        .game-over button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
        }
        @media (max-width: 768px) {
            .container { flex-direction: column; }
            .panel, .canvas-container, .log-panel { flex: 1; min-width: auto; }
            #svgCanvas { height: 500px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-title">ì¢Œí‘œí‰ë©´ ì§€ë¢° ê²Œì„</div>
        <div class="header-author">made by ì‹ ì„œì¤‘ ì •ë‹¤ì˜ğŸ©·</div>
        <div class="stage-indicator" id="stageIndicator">
            <div class="stage-item active" data-stage="1">
                <span>1ë‹¨ê³„</span>
            </div>
            <div class="stage-connector"></div>
            <div class="stage-item" data-stage="2">
                <span>2ë‹¨ê³„</span>
            </div>
            <div class="stage-connector"></div>
            <div class="stage-item" data-stage="3">
                <span>3ë‹¨ê³„</span>
            </div>
        </div>
        <div id="stageDescription" style="text-align: center; color: white; font-size: 16px; margin-top: 10px; padding: 0 20px; font-weight: bold;"></div>
    </div>
    <div class="container">
        <div class="panel">
            <div id="minesPreview" class="mines-preview" style="margin-bottom: 15px;"></div>
            <button id="startBtn">ê²Œì„ì‹œì‘</button>
            <button id="resetBtn" disabled>ë‹¤ì‹œì‹œì‘</button>
            
            <div class="info-item">
                <strong>ë‚¨ì€ ì§€ë¢°:</strong> <span id="minesLeft">3</span>
            </div>
            <div class="info-item">
                <strong>ì‹œë„ íšŸìˆ˜:</strong> <span id="tries">0</span>
            </div>
            <div class="info-item">
                <strong>ì ì¤‘ íšŸìˆ˜:</strong> <span id="hits">0</span>
            </div>
            <div class="info-item">
                <strong>ì ìˆ˜:</strong> <span id="score">0</span>
            </div>
            
            <div class="input-group">
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <input type="text" id="input" placeholder="" disabled>
                    <div class="input-error" id="inputError">ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”ğŸ¥²</div>
                </div>
                <button id="submitBtn" disabled>í™•ì¸</button>
            </div>
            
        </div>
        
        <div class="canvas-container">
            <svg id="svgCanvas" viewBox="0 0 640 640" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#333" />
                    </marker>
                </defs>
                <g id="grid"></g>
                <g id="axes"></g>
                <g id="mines"></g>
                <g id="marks"></g>
                <g id="lines"></g>
            </svg>
        </div>
        
        <div class="log-panel">
            <div style="font-weight: bold; margin-bottom: 10px; color: #667eea; font-size: 16px;">ğŸ’¡ íŒíŠ¸</div>
            <div class="log-area" id="autoHintsList" style="max-height: 500px; overflow-y: auto; font-size: 13px; line-height: 1.6;"></div>
        </div>
    </div>
    
    <script>
        (function() {
            const SVG_SIZE = 640;
            const GRID_MIN = -5, GRID_MAX = 5;
            const GRID_SIZE = GRID_MAX - GRID_MIN + 1;
            const PADDING = 60;
            const CELL_SIZE = (SVG_SIZE - 2 * PADDING) / GRID_SIZE;
            
            // ìƒíƒœ ê´€ë¦¬
            const state = {
                mines: new Set(),
                tried: new Set(),
                hits: new Set(),
                score: 0,
                tries: 0,
                found: 0,
                started: false,
                startTime: null,
                currentHint: null,
                shownHints: new Set(), // ì´ë¯¸ í‘œì‹œëœ íŒíŠ¸ í…ìŠ¤íŠ¸ (ì¤‘ë³µ ë°©ì§€)
                currentStage: 2, // í˜„ì¬ ë‹¨ê³„ (2ë‹¨ê³„ ê³ ì •)
                totalScore: 0, // ì „ì²´ ì ìˆ˜ (ëª¨ë“  ë‹¨ê³„ ëˆ„ì )
                stage2K: null, // 2ë‹¨ê³„ ì •ë¹„ë¡€ k ê°’
                stage2KInv: null, // 2ë‹¨ê³„ ë°˜ë¹„ë¡€ k ê°’
                firstHintShown: false, // ì²« ë²ˆì§¸ íŒíŠ¸ í‘œì‹œ ì—¬ë¶€
                lastHintTries: -1 // ë§ˆì§€ë§‰ìœ¼ë¡œ íŒíŠ¸ë¥¼ í‘œì‹œí•œ ì‹œë„ íšŸìˆ˜
            };
            
            // DOM ìš”ì†Œ
            const elements = {
                startBtn: document.getElementById('startBtn'),
                resetBtn: document.getElementById('resetBtn'),
                input: document.getElementById('input'),
                submitBtn: document.getElementById('submitBtn'),
                minesLeft: document.getElementById('minesLeft'),
                tries: document.getElementById('tries'),
                hits: document.getElementById('hits'),
                score: document.getElementById('score'),
                svg: document.getElementById('svgCanvas'),
                grid: document.getElementById('grid'),
                axes: document.getElementById('axes'),
                mines: document.getElementById('mines'),
                marks: document.getElementById('marks'),
                lines: document.getElementById('lines'),
                autoHintsList: document.getElementById('autoHintsList'),
                stageIndicator: document.getElementById('stageIndicator'),
                inputError: document.getElementById('inputError'),
                minesPreview: null // ë™ì ìœ¼ë¡œ ìƒì„±
            };
            
            // ì¢Œí‘œ ë³€í™˜: ê²©ì ì¢Œí‘œ â†’ SVG í”½ì…€
            function gridToSvg(x, y) {
                const svgX = PADDING + (x - GRID_MIN) * CELL_SIZE;
                const svgY = PADDING + (GRID_MAX - y) * CELL_SIZE;
                return [svgX, svgY];
            }
            
            // ì¢Œí‘œ ë³€í™˜: SVG í”½ì…€ â†’ ê²©ì ì¢Œí‘œ
            function svgToGrid(px, py) {
                const x = Math.round((px - PADDING) / CELL_SIZE + GRID_MIN);
                const y = Math.round(GRID_MAX - (py - PADDING) / CELL_SIZE);
                return [x, y];
            }
            
            // í‚¤ ë³€í™˜ ìœ í‹¸
            function toKey(x, y) { return `${x},${y}`; }
            function fromKey(key) { return key.split(',').map(Number); }
            function isInt(n) { return Number.isInteger(n) && Math.abs(n - Math.round(n)) < 1e-10; }
            
            // ë¶„ìˆ˜ íŒŒì‹± (a/b â†’ number)
            function parseRational(str) {
                if (str.includes('/')) {
                    const [a, b] = str.split('/').map(s => parseFloat(s.trim()));
                    return b !== 0 ? a / b : NaN;
                }
                return parseFloat(str);
            }
            
            // ì…ë ¥ íŒŒì‹±
            function parseInput(str) {
                str = str.trim();
                
                // ì : (x, y) ë˜ëŠ” (x,y) - ê³µë°± ìœ ë¬´ ìƒê´€ì—†ì´
                const pointMatch = str.match(/^\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)\s*$/);
                if (pointMatch) {
                    const x = parseInt(pointMatch[1]);
                    const y = parseInt(pointMatch[2]);
                    if (x >= GRID_MIN && x <= GRID_MAX && y >= GRID_MIN && y <= GRID_MAX) {
                        return { type: 'point', x, y };
                    }
                    return { type: 'error', msg: 'ì¢Œí‘œëŠ” -5~5 ë²”ìœ„ì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.' };
                }
                
                // 2ë‹¨ê³„ì—ì„œëŠ” ìˆœì„œìŒ, ì •ë¹„ë¡€, ë°˜ë¹„ë¡€ ëª¨ë‘ í—ˆìš©
                
                // ì •ë¹„ë¡€: y = kx ë˜ëŠ” y = k*x ë˜ëŠ” y = x ë˜ëŠ” y = -x (k=1/-1 ìƒëµ ê°€ëŠ¥)
                // ìŒì˜ ë¶„ìˆ˜ ì§€ì›: y = (-1/3)x, y = (-2/5)*x ë“±
                const propMatch = str.match(/^\s*y\s*=\s*([+-]?\d+(?:\.\d+)?|\(?[+-]?\d+\/\d+\)?|[+-])\s*\*\s*x\s*$|^\s*y\s*=\s*([+-]?\d+(?:\.\d+)?|\(?[+-]?\d+\/\d+\)?|[+-])\s*x\s*$|^\s*y\s*=\s*([+-]?)\s*x\s*$/);
                if (propMatch) {
                    let kStr = (propMatch[1] || propMatch[2] || propMatch[3] || '1').trim();
                    // ë¶€í˜¸ë§Œ ìˆëŠ” ê²½ìš° ì²˜ë¦¬ (+, -)
                    if (kStr === '+' || kStr === '') {
                        kStr = '1';
                    } else if (kStr === '-') {
                        kStr = '-1';
                    }
                    kStr = kStr.replace(/[()]/g, ''); // ê´„í˜¸ ì œê±°
                    const k = parseRational(kStr);
                    if (!isNaN(k)) {
                        return { type: 'proportional', k };
                    }
                    return { type: 'error', msg: 'ê³„ìˆ˜ kë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
                }
                
                // ë°˜ë¹„ë¡€: y = k/x (ê´„í˜¸ í¬í•¨ ë¶„ìˆ˜ í—ˆìš©)
                const invMatch = str.match(/^\s*y\s*=\s*([^/]+?)\s*\/\s*x\s*$/);
                if (invMatch) {
                    let kStr = invMatch[1].trim();
                    kStr = kStr.replace(/[()]/g, ''); // ê´„í˜¸ ì œê±°
                    const k = parseRational(kStr);
                    if (!isNaN(k)) {
                        return { type: 'inverse', k };
                    }
                    return { type: 'error', msg: 'ê³„ìˆ˜ kë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
                }
                
                return { type: 'error', msg: 'ì •ìˆ˜ ìˆœì„œìŒ (x,y), ì •ë¹„ë¡€ y=kx, ë°˜ë¹„ë¡€ y=k/x í˜•íƒœë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.' };
            }
            
            // ê²©ì ê·¸ë¦¬ê¸°
            function drawGrid() {
                elements.grid.innerHTML = '';
                const svgNS = 'http://www.w3.org/2000/svg';
                
                for (let i = GRID_MIN; i <= GRID_MAX; i++) {
                    const [x1, y1] = gridToSvg(i, GRID_MIN);
                    const [x2, y2] = gridToSvg(i, GRID_MAX);
                    const [x3, y3] = gridToSvg(GRID_MIN, i);
                    const [x4, y4] = gridToSvg(GRID_MAX, i);
                    
                    // ì„¸ë¡œì„ 
                    const vLine = document.createElementNS(svgNS, 'line');
                    vLine.setAttribute('x1', x1);
                    vLine.setAttribute('y1', y1);
                    vLine.setAttribute('x2', x2);
                    vLine.setAttribute('y2', y2);
                    vLine.setAttribute('stroke', '#e0e0e0');
                    vLine.setAttribute('stroke-width', '1');
                    elements.grid.appendChild(vLine);
                    
                    // ê°€ë¡œì„ 
                    const hLine = document.createElementNS(svgNS, 'line');
                    hLine.setAttribute('x1', x3);
                    hLine.setAttribute('y1', y3);
                    hLine.setAttribute('x2', x4);
                    hLine.setAttribute('y2', y4);
                    hLine.setAttribute('stroke', '#e0e0e0');
                    hLine.setAttribute('stroke-width', '1');
                    elements.grid.appendChild(hLine);
                }
            }
            
            // ì¶• ê·¸ë¦¬ê¸°
            function drawAxes() {
                elements.axes.innerHTML = '';
                const svgNS = 'http://www.w3.org/2000/svg';
                const [ox, oy] = gridToSvg(0, 0);
                const [xMin, yMin] = gridToSvg(GRID_MIN, 0);
                const [xMax, yMax] = gridToSvg(GRID_MAX, 0);
                const [x0, y0] = gridToSvg(0, GRID_MIN);  // ì•„ë˜ìª½
                const [x1, y1] = gridToSvg(0, GRID_MAX);  // ìœ„ìª½
                
                // xì¶• (ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
                const xAxis = document.createElementNS(svgNS, 'line');
                xAxis.setAttribute('x1', xMin);
                xAxis.setAttribute('y1', oy);
                xAxis.setAttribute('x2', xMax);
                xAxis.setAttribute('y2', oy);
                xAxis.setAttribute('stroke', '#333');
                xAxis.setAttribute('stroke-width', '2');
                xAxis.setAttribute('marker-end', 'url(#arrowhead)');
                elements.axes.appendChild(xAxis);
                
                // yì¶• (ì•„ë˜ì—ì„œ ìœ„ë¡œ)
                const yAxis = document.createElementNS(svgNS, 'line');
                yAxis.setAttribute('x1', ox);
                yAxis.setAttribute('y1', y0);
                yAxis.setAttribute('x2', ox);
                yAxis.setAttribute('y2', y1);
                yAxis.setAttribute('stroke', '#333');
                yAxis.setAttribute('stroke-width', '2');
                yAxis.setAttribute('marker-end', 'url(#arrowhead)');
                elements.axes.appendChild(yAxis);
                
                // ì›ì 
                const origin = document.createElementNS(svgNS, 'circle');
                origin.setAttribute('cx', ox);
                origin.setAttribute('cy', oy);
                origin.setAttribute('r', '5');
                origin.setAttribute('fill', '#333');
                elements.axes.appendChild(origin);
                
                // ì¶• ì´ë¦„ (xì¶•: ì˜¤ë¥¸ìª½ ë, yì¶•: ìœ„ìª½ ë)
                const xLabel = document.createElementNS(svgNS, 'text');
                xLabel.setAttribute('x', xMax + 15);
                xLabel.setAttribute('y', oy + 5);
                xLabel.setAttribute('font-size', '16');
                xLabel.setAttribute('font-weight', 'bold');
                xLabel.setAttribute('fill', '#333');
                xLabel.textContent = 'x';
                elements.axes.appendChild(xLabel);
                
                const yLabel = document.createElementNS(svgNS, 'text');
                yLabel.setAttribute('x', ox + 5);
                yLabel.setAttribute('y', y1 - 10);
                yLabel.setAttribute('font-size', '16');
                yLabel.setAttribute('font-weight', 'bold');
                yLabel.setAttribute('fill', '#333');
                yLabel.textContent = 'y';
                elements.axes.appendChild(yLabel);
                
                // ëˆˆê¸ˆ ë° ë¼ë²¨
                for (let i = GRID_MIN; i <= GRID_MAX; i++) {
                    const [x, y] = gridToSvg(i, 0);
                    const [x2, y2] = gridToSvg(0, i);
                    
                    // xì¶• ëˆˆê¸ˆ
                    const xTick = document.createElementNS(svgNS, 'line');
                    xTick.setAttribute('x1', x);
                    xTick.setAttribute('y1', oy - 5);
                    xTick.setAttribute('x2', x);
                    xTick.setAttribute('y2', oy + 5);
                    xTick.setAttribute('stroke', '#333');
                    xTick.setAttribute('stroke-width', '2');
                    elements.axes.appendChild(xTick);
                    
                    // yì¶• ëˆˆê¸ˆ
                    const yTick = document.createElementNS(svgNS, 'line');
                    yTick.setAttribute('x1', ox - 5);
                    yTick.setAttribute('y1', y2);
                    yTick.setAttribute('x2', ox + 5);
                    yTick.setAttribute('y2', y2);
                    yTick.setAttribute('stroke', '#333');
                    yTick.setAttribute('stroke-width', '2');
                    elements.axes.appendChild(yTick);
                    
                    if (i !== 0) {
                        // xì¶• ë¼ë²¨
                        const xText = document.createElementNS(svgNS, 'text');
                        xText.setAttribute('x', x);
                        xText.setAttribute('y', oy + 25);
                        xText.setAttribute('text-anchor', 'middle');
                        xText.setAttribute('font-size', '14');
                        xText.setAttribute('fill', '#333');
                        xText.textContent = i.toString();
                        elements.axes.appendChild(xText);
                        
                        // yì¶• ë¼ë²¨
                        const yText = document.createElementNS(svgNS, 'text');
                        yText.setAttribute('x', ox - 25);
                        yText.setAttribute('y', y2 + 5);
                        yText.setAttribute('text-anchor', 'middle');
                        yText.setAttribute('font-size', '14');
                        yText.setAttribute('fill', '#333');
                        yText.textContent = i.toString();
                        elements.axes.appendChild(yText);
                    }
                }
            }
            
            // ì  ê·¸ë¦¬ê¸° (ê³ ìœ  ID í¬í•¨)
            function drawPoint(x, y, style) {
                const svgNS = 'http://www.w3.org/2000/svg';
                const [sx, sy] = gridToSvg(x, y);
                const color = style === 'hit' ? '#dc3545' : style === 'miss' ? '#999' : '#667eea';
                const radius = style === 'hit' ? 8 : 6;
                const pointId = `point-${x}-${y}-${style}`;
                
                const group = document.createElementNS(svgNS, 'g');
                group.setAttribute('id', pointId);
                group.setAttribute('data-x', x);
                group.setAttribute('data-y', y);
                
                if (style === 'miss') {
                    const line1 = document.createElementNS(svgNS, 'line');
                    line1.setAttribute('x1', sx - 6);
                    line1.setAttribute('y1', sy - 6);
                    line1.setAttribute('x2', sx + 6);
                    line1.setAttribute('y2', sy + 6);
                    line1.setAttribute('stroke', color);
                    line1.setAttribute('stroke-width', '2');
                    
                    const line2 = document.createElementNS(svgNS, 'line');
                    line2.setAttribute('x1', sx + 6);
                    line2.setAttribute('y1', sy - 6);
                    line2.setAttribute('x2', sx - 6);
                    line2.setAttribute('y2', sy + 6);
                    line2.setAttribute('stroke', color);
                    line2.setAttribute('stroke-width', '2');
                    
                    group.appendChild(line1);
                    group.appendChild(line2);
                    return group;
                }
                
                // í­íƒ„ ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
                if (style === 'hit') {
                    group.classList.add('explosion');
                    
                    const body = document.createElementNS(svgNS, 'circle');
                    body.setAttribute('cx', sx);
                    body.setAttribute('cy', sy);
                    body.setAttribute('r', '12');
                    body.setAttribute('fill', '#dc3545');
                    body.setAttribute('stroke', '#8b0000');
                    body.setAttribute('stroke-width', '2');
                    
                    const fuse = document.createElementNS(svgNS, 'circle');
                    fuse.setAttribute('cx', sx);
                    fuse.setAttribute('cy', sy - 4);
                    fuse.setAttribute('r', '3');
                    fuse.setAttribute('fill', '#ffd700');
                    
                    const spark1 = document.createElementNS(svgNS, 'line');
                    spark1.setAttribute('x1', sx);
                    spark1.setAttribute('y1', sy - 8);
                    spark1.setAttribute('x2', sx);
                    spark1.setAttribute('y2', sy - 16);
                    spark1.setAttribute('stroke', '#ff6b6b');
                    spark1.setAttribute('stroke-width', '2');
                    spark1.setAttribute('stroke-linecap', 'round');
                    
                    const spark2 = document.createElementNS(svgNS, 'line');
                    spark2.setAttribute('x1', sx - 3);
                    spark2.setAttribute('y1', sy - 12);
                    spark2.setAttribute('x2', sx - 6);
                    spark2.setAttribute('y2', sy - 18);
                    spark2.setAttribute('stroke', '#ff6b6b');
                    spark2.setAttribute('stroke-width', '1.5');
                    spark2.setAttribute('stroke-linecap', 'round');
                    
                    const spark3 = document.createElementNS(svgNS, 'line');
                    spark3.setAttribute('x1', sx + 3);
                    spark3.setAttribute('y1', sy - 12);
                    spark3.setAttribute('x2', sx + 6);
                    spark3.setAttribute('y2', sy - 18);
                    spark3.setAttribute('stroke', '#ff6b6b');
                    spark3.setAttribute('stroke-width', '1.5');
                    spark3.setAttribute('stroke-linecap', 'round');
                    
                    const base1 = document.createElementNS(svgNS, 'rect');
                    base1.setAttribute('x', sx - 8);
                    base1.setAttribute('y', sy + 4);
                    base1.setAttribute('width', '16');
                    base1.setAttribute('height', '4');
                    base1.setAttribute('fill', '#333');
                    base1.setAttribute('rx', '1');
                    
                    const base2 = document.createElementNS(svgNS, 'rect');
                    base2.setAttribute('x', sx - 6);
                    base2.setAttribute('y', sy + 8);
                    base2.setAttribute('width', '12');
                    base2.setAttribute('height', '2');
                    base2.setAttribute('fill', '#333');
                    base2.setAttribute('rx', '1');
                    
                    group.appendChild(body);
                    group.appendChild(fuse);
                    group.appendChild(spark1);
                    group.appendChild(spark2);
                    group.appendChild(spark3);
                    group.appendChild(base1);
                    group.appendChild(base2);
                    return group;
                }
                
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('id', pointId);
                circle.setAttribute('data-x', x);
                circle.setAttribute('data-y', y);
                circle.setAttribute('cx', sx);
                circle.setAttribute('cy', sy);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', color);
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                return circle;
            }
            
            // ì„  ê·¸ë¦¬ê¸° (ì •ë¹„ë¡€/ë°˜ë¹„ë¡€)
            function drawLine(fn, type, k) {
                const gridPoints = []; // ê²©ìì  (ì •ìˆ˜ ì¢Œí‘œ)
                
                if (type === 'inverse') {
                    // ë°˜ë¹„ë¡€: ê³¡ì„ ìœ¼ë¡œ ê·¸ë¦¬ê¸° ìœ„í•´ ë” ì„¸ë°€í•œ ì  ì‚¬ìš©
                    const step = 0.05; // ë” ì„¸ë°€í•œ ê°„ê²©
                    
                    // ìŒìˆ˜ ë¶€ë¶„ (x < 0)
                    const negativePoints = [];
                    for (let x = GRID_MIN; x < -0.1; x += step) {
                        const y = fn(x);
                        if (y >= GRID_MIN && y <= GRID_MAX) {
                            const [sx, sy] = gridToSvg(x, y);
                            negativePoints.push([sx, sy]);
                        }
                    }
                    
                    // ì–‘ìˆ˜ ë¶€ë¶„ (x > 0)
                    const positivePoints = [];
                    for (let x = 0.1; x <= GRID_MAX; x += step) {
                        const y = fn(x);
                        if (y >= GRID_MIN && y <= GRID_MAX) {
                            const [sx, sy] = gridToSvg(x, y);
                            positivePoints.push([sx, sy]);
                        }
                    }
                    
                    // ê²©ìì ë„ ìˆ˜ì§‘ (ë§ˆì»¤ í‘œì‹œìš©)
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        if (x === 0) continue;
                        const y = fn(x);
                        if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                            gridPoints.push([x, y]);
                        }
                    }
                    
                    // ê³¡ì„  ê²½ë¡œ ìƒì„± (ì–‘ìˆ˜ì™€ ìŒìˆ˜ ë¶€ë¶„ì„ ë¶„ë¦¬)
                    let path = '';
                    if (negativePoints.length > 0) {
                        path += 'M ' + negativePoints.map(([sx, sy]) => `${sx} ${sy}`).join(' L ');
                    }
                    if (positivePoints.length > 0) {
                        if (path) path += ' M ';
                        path += positivePoints.map(([sx, sy]) => `${sx} ${sy}`).join(' L ');
                    }
                    
                    return { path, points: gridPoints };
                } else {
                    // ì •ë¹„ë¡€: ì „ì²´ ì¢Œí‘œí‰ë©´ ìœ„ì— ì§ì„ ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                    // kê°€ ì—†ìœ¼ë©´ í•¨ìˆ˜ì—ì„œ ì¶”ì¶œ (y = kx í˜•íƒœ)
                    if (k === undefined) {
                        // í…ŒìŠ¤íŠ¸ í¬ì¸íŠ¸ë¡œ k ê°’ ì¶”ì •
                        const testY1 = fn(1);
                        const testY2 = fn(-1);
                        if (testY1 !== undefined && !isNaN(testY1)) {
                            k = testY1;
                        } else if (testY2 !== undefined && !isNaN(testY2)) {
                            k = -testY2;
                        } else {
                            k = 0;
                        }
                    }
                    
                    // ê²½ê³„ì™€ì˜ êµì°¨ì  ê³„ì‚°
                    const intersections = [];
                    
                    // x = GRID_MIN, x = GRID_MAX ê²½ê³„ì™€ì˜ êµì°¨
                    let yAtMinX = fn(GRID_MIN);
                    let yAtMaxX = fn(GRID_MAX);
                    
                    if (yAtMinX !== undefined && !isNaN(yAtMinX) && yAtMinX >= GRID_MIN && yAtMinX <= GRID_MAX) {
                        intersections.push([GRID_MIN, yAtMinX]);
                    }
                    if (yAtMaxX !== undefined && !isNaN(yAtMaxX) && yAtMaxX >= GRID_MIN && yAtMaxX <= GRID_MAX) {
                        intersections.push([GRID_MAX, yAtMaxX]);
                    }
                    
                    // y = GRID_MIN, y = GRID_MAX ê²½ê³„ì™€ì˜ êµì°¨
                    if (Math.abs(k) > 0.001) {
                        let xAtMinY = GRID_MIN / k;
                        let xAtMaxY = GRID_MAX / k;
                        
                        if (xAtMinY >= GRID_MIN && xAtMinY <= GRID_MAX) {
                            intersections.push([xAtMinY, GRID_MIN]);
                        }
                        if (xAtMaxY >= GRID_MIN && xAtMaxY <= GRID_MAX) {
                            intersections.push([xAtMaxY, GRID_MAX]);
                        }
                    } else {
                        // y = 0 (ìˆ˜í‰ì„ )
                        intersections.push([GRID_MIN, 0]);
                        intersections.push([GRID_MAX, 0]);
                    }
                    
                    // ì¤‘ë³µ ì œê±° ë° ì •ë ¬
                    const uniqueIntersections = [];
                    const seen = new Set();
                    intersections.forEach(([x, y]) => {
                        const key = `${x.toFixed(2)},${y.toFixed(2)}`;
                        if (!seen.has(key)) {
                            seen.add(key);
                            uniqueIntersections.push([x, y]);
                        }
                    });
                    
                    // ë‘ êµì°¨ì  ì„ íƒ (ê°€ì¥ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½)
                    if (uniqueIntersections.length >= 2) {
                        uniqueIntersections.sort((a, b) => a[0] - b[0]);
                        let startPoint = uniqueIntersections[0];
                        let endPoint = uniqueIntersections[uniqueIntersections.length - 1];
                        
                        // SVG ì¢Œí‘œë¡œ ë³€í™˜
                        const [sx1, sy1] = gridToSvg(startPoint[0], startPoint[1]);
                        const [sx2, sy2] = gridToSvg(endPoint[0], endPoint[1]);
                        
                        // ì§ì„  ê²½ë¡œ ìƒì„±
                        const path = `M ${sx1} ${sy1} L ${sx2} ${sy2}`;
                        
                        // ê²©ìì  ìˆ˜ì§‘ (ë§ˆì»¤ í‘œì‹œìš©)
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            const y = fn(x);
                            if (y !== undefined && !isNaN(y) && isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                gridPoints.push([x, y]);
                            }
                        }
                        
                        return { path, points: gridPoints };
                    } else {
                        // êµì°¨ì ì´ ë¶€ì¡±í•œ ê²½ìš° ê²©ìì ë§Œ ì‚¬ìš©
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            const y = fn(x);
                            if (y !== undefined && !isNaN(y) && isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                gridPoints.push([x, y]);
                            }
                        }
                        // ìµœì†Œí•œ ë‘ ì ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°
                        if (gridPoints.length >= 2) {
                            const [sx1, sy1] = gridToSvg(gridPoints[0][0], gridPoints[0][1]);
                            const [sx2, sy2] = gridToSvg(gridPoints[gridPoints.length - 1][0], gridPoints[gridPoints.length - 1][1]);
                            const path = `M ${sx1} ${sy1} L ${sx2} ${sy2}`;
                            return { path, points: gridPoints };
                        }
                        return { path: '', points: gridPoints };
                    }
                }
            }
            
            // ì§€ë¢° ë°°ì¹˜
            function placeMines() {
                state.mines.clear();
                
                // 1ë‹¨ê³„: ì¶• ìœ„ 1ê°œ + ì¶• ìœ„ ì—†ëŠ” 2ê°œ - ì‚¬ìš© ì•ˆ í•¨
                if (false) {
                    // ì¶• ìœ„ì— 1ê°œ ë°°ì¹˜ (xì¶• ë˜ëŠ” yì¶•)
                    const onXAxis = Math.random() < 0.5;
                    if (onXAxis) {
                        // xì¶• ìœ„ (y = 0) - ì›ì  ì œì™¸
                        const xValues = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            if (x !== 0) {
                                xValues.push(x);
                            }
                        }
                        const shuffled = xValues.sort(() => Math.random() - 0.5);
                        const x = shuffled[0];
                        state.mines.add(toKey(x, 0));
                    } else {
                        // yì¶• ìœ„ (x = 0) - ì›ì  ì œì™¸
                        const yValues = [];
                        for (let y = GRID_MIN; y <= GRID_MAX; y++) {
                            if (y !== 0) {
                                yValues.push(y);
                            }
                        }
                        const shuffled = yValues.sort(() => Math.random() - 0.5);
                        const y = shuffled[0];
                        state.mines.add(toKey(0, y));
                    }
                    
                    // ì¶• ìœ„ì— ì—†ëŠ” ì •ìˆ˜ì  2ê°œ ë°°ì¹˜
                    const offAxisPoints = [];
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        for (let y = GRID_MIN; y <= GRID_MAX; y++) {
                            if (x !== 0 && y !== 0) {
                                offAxisPoints.push([x, y]);
                            }
                        }
                    }
                    const shuffled = offAxisPoints.sort(() => Math.random() - 0.5);
                    for (let i = 0; i < 2 && i < shuffled.length; i++) {
                        const [x, y] = shuffled[i];
                        const key = toKey(x, y);
                        if (!state.mines.has(key)) {
                            state.mines.add(key);
                        }
                    }
                    
                    updateMineDisplay();
                    updateMinesPreview();
                    return;
                }
                
                // 2ë‹¨ê³„: ì •ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ 2ê°œ, ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ 2ê°œ (ì´ 4ê°œ)
                {
                    // ì •ë¹„ë¡€ í•¨ìˆ˜ì™€ ë°˜ë¹„ë¡€ í•¨ìˆ˜ì˜ k ê°’ ì„ íƒ
                    const possibleK = [-3, -2.5, -2, -1.5, -1, -0.5, 0.5, 1, 1.5, 2, 2.5, 3];
                    const possibleKInv = [-20, -15, -12, -10, -8, -6, -4, -2, 2, 4, 6, 8, 10, 12, 15, 20];
                    
                    let k, kInv;
                    let intersectionPoints = [];
                    let foundValidPair = false;
                    let attempts = 0;
                    
                    // êµì ì´ ì—†ëŠ” k, kInv ì¡°í•© ì°¾ê¸°
                    while (!foundValidPair && attempts < 50) {
                        // ì´ì „ ê²Œì„ì—ì„œ ì‚¬ìš©í•œ k ê°’ì€ ê°€ëŠ¥í•œ í•œ í”¼í•˜ê¸° ìœ„í•´ ë‹¤ì‹œ ë½‘ê¸°
                        k = possibleK[Math.floor(Math.random() * possibleK.length)];
                        kInv = possibleKInv[Math.floor(Math.random() * possibleKInv.length)];
                        
                        // ì •ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ëª¨ë“  ê²©ìì ë“¤ ì°¾ê¸°
                        const propAllPoints = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            const y = k * x;
                            if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                propAllPoints.push([x, y]);
                            }
                        }
                        
                        // ë°˜ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ëª¨ë“  ê²©ìì ë“¤ ì°¾ê¸°
                        const invAllPoints = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            if (x === 0) continue;
                            const y = kInv / x;
                            if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                invAllPoints.push([x, y]);
                            }
                        }
                        
                        // êµì  ê³„ì‚°: ë‘ í•¨ìˆ˜ê°€ ê³µí†µìœ¼ë¡œ ê°€ì§€ëŠ” ê²©ìì 
                        intersectionPoints = [];
                        propAllPoints.forEach(([px, py]) => {
                            invAllPoints.forEach(([ix, iy]) => {
                                if (px === ix && py === iy) {
                                    intersectionPoints.push([px, py]);
                                }
                            });
                        });
                        
                        // ì •ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ê²©ìì ë“¤ ì°¾ê¸° (êµì  ì œì™¸)
                        const propCandidates = propAllPoints.filter(([x, y]) => {
                            return !intersectionPoints.some(([ix, iy]) => ix === x && iy === y);
                        });
                        
                        // ë°˜ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ê²©ìì ë“¤ ì°¾ê¸° (êµì  ì œì™¸)
                        const invCandidates = invAllPoints.filter(([x, y]) => {
                            return !intersectionPoints.some(([ix, iy]) => ix === x && iy === y);
                        });
                        
                        // ê° í•¨ìˆ˜ ìœ„ì— ìµœì†Œ 2ê°œ ì´ìƒì˜ ê²©ìì ì´ ìˆëŠ”ì§€ í™•ì¸
                        if (propCandidates.length >= 2 && invCandidates.length >= 2) {
                            foundValidPair = true;
                            
                            // 1. ì •ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì— 2ê°œ ë°°ì¹˜
                            const shuffledProp = propCandidates.sort(() => Math.random() - 0.5);
                            for (let i = 0; i < 2 && i < shuffledProp.length; i++) {
                                const [x, y] = shuffledProp[i];
                                state.mines.add(toKey(x, y));
                            }
                            
                            // 2. ë°˜ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì— 2ê°œ ë°°ì¹˜ (êµì  ì œì™¸)
                            const shuffledInv = invCandidates.sort(() => Math.random() - 0.5);
                            let invPlaced = 0;
                            for (let i = 0; i < shuffledInv.length && invPlaced < 2; i++) {
                                const [x, y] = shuffledInv[i];
                                const key = toKey(x, y);
                                if (!state.mines.has(key)) {
                                    state.mines.add(key);
                                    invPlaced++;
                                }
                            }
                        }
                        attempts++;
                    }
                    
                    // ìœ íš¨í•œ ì¡°í•©ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ê°’ ì‚¬ìš©
                    if (!foundValidPair) {
                        k = 1;
                        kInv = 6;
                        // ê¸°ë³¸ê°’ìœ¼ë¡œ ë°°ì¹˜
                        const propCandidates = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            const y = k * x;
                            if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                propCandidates.push([x, y]);
                            }
                        }
                        const shuffledProp = propCandidates.sort(() => Math.random() - 0.5);
                        for (let i = 0; i < 2 && i < shuffledProp.length; i++) {
                            const [x, y] = shuffledProp[i];
                            state.mines.add(toKey(x, y));
                        }
                        
                        const invCandidates = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            if (x === 0) continue;
                            const y = kInv / x;
                            if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                const key = toKey(x, y);
                                if (!state.mines.has(key)) {
                                    invCandidates.push([x, y]);
                                }
                            }
                        }
                        const shuffledInv = invCandidates.sort(() => Math.random() - 0.5);
                        for (let i = 0; i < 2 && i < shuffledInv.length; i++) {
                            const [x, y] = shuffledInv[i];
                            state.mines.add(toKey(x, y));
                        }
                    }
                    
                    // 2ë‹¨ê³„ k ê°’ ì €ì¥
                    state.stage2K = k;
                    state.stage2KInv = kInv;
                    
                    updateMineDisplay();
                    updateMinesPreview();
                    return;
                }
                
                // 3ë‹¨ê³„: ê¸°ì¡´ ë¡œì§ ì‚¬ìš© (ì •ë¹„ë¡€ 2ê°œ, ë°˜ë¹„ë¡€ 2ê°œ, ì¶• ìœ„ 1ê°œ = ì´ 5ê°œ)
                // ì •ë¹„ë¡€ í•¨ìˆ˜ì™€ ë°˜ë¹„ë¡€ í•¨ìˆ˜ì˜ k ê°’ ì„ íƒ
                const possibleK = [-2, -1, -0.5, 0.5, 1, 2, -1.5, 1.5, -3, 3, -2.5, 2.5];
                const possibleKInv = [-12, -10, -8, -6, -4, -2, 2, 4, 6, 8, 10, 12, -15, 15, -20, 20];
                
                let k, kInv;
                let intersectionPoints = [];
                let foundValidPair = false;
                let attempts = 0;
                
                // êµì ì´ ì—†ëŠ” k, kInv ì¡°í•© ì°¾ê¸°
                while (!foundValidPair && attempts < 50) {
                    k = possibleK[Math.floor(Math.random() * possibleK.length)];
                    kInv = possibleKInv[Math.floor(Math.random() * possibleKInv.length)];
                    
                    // ì •ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ëª¨ë“  ê²©ìì ë“¤ ì°¾ê¸°
                    const propAllPoints = [];
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        const y = k * x;
                        if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                            propAllPoints.push([x, y]);
                        }
                    }
                    
                    // ë°˜ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ëª¨ë“  ê²©ìì ë“¤ ì°¾ê¸°
                    const invAllPoints = [];
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        if (x === 0) continue;
                        const y = kInv / x;
                        if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                            invAllPoints.push([x, y]);
                        }
                    }
                    
                    // êµì  ê³„ì‚°: ë‘ í•¨ìˆ˜ê°€ ê³µí†µìœ¼ë¡œ ê°€ì§€ëŠ” ê²©ìì 
                    intersectionPoints = [];
                    propAllPoints.forEach(([px, py]) => {
                        invAllPoints.forEach(([ix, iy]) => {
                            if (px === ix && py === iy) {
                                intersectionPoints.push([px, py]);
                            }
                        });
                    });
                    
                    // ì •ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ê²©ìì ë“¤ ì°¾ê¸° (êµì  ì œì™¸)
                    const propCandidates = propAllPoints.filter(([x, y]) => {
                        return !intersectionPoints.some(([ix, iy]) => ix === x && iy === y);
                    });
                    
                    // ë°˜ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì˜ ê²©ìì ë“¤ ì°¾ê¸° (êµì  ì œì™¸)
                    const invCandidates = invAllPoints.filter(([x, y]) => {
                        return !intersectionPoints.some(([ix, iy]) => ix === x && iy === y);
                    });
                    
                    // ê° í•¨ìˆ˜ ìœ„ì— ìµœì†Œ 2ê°œ ì´ìƒì˜ ê²©ìì ì´ ìˆëŠ”ì§€ í™•ì¸
                    if (propCandidates.length >= 2 && invCandidates.length >= 2) {
                        foundValidPair = true;
                        
                        // 1. ì •ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì— 2ê°œ ë°°ì¹˜
                        const shuffledProp = propCandidates.sort(() => Math.random() - 0.5);
                        for (let i = 0; i < 2 && i < shuffledProp.length; i++) {
                            const [x, y] = shuffledProp[i];
                            state.mines.add(toKey(x, y));
                        }
                        
                        // 2. ë°˜ë¹„ë¡€ í•¨ìˆ˜ ìœ„ì— 2ê°œ ë°°ì¹˜ (êµì  ì œì™¸)
                        const shuffledInv = invCandidates.sort(() => Math.random() - 0.5);
                        let invPlaced = 0;
                        for (let i = 0; i < shuffledInv.length && invPlaced < 2; i++) {
                            const [x, y] = shuffledInv[i];
                            const key = toKey(x, y);
                            if (!state.mines.has(key)) {
                                state.mines.add(key);
                                invPlaced++;
                            }
                        }
                        
                        // 2ë‹¨ê³„ k ê°’ ì €ì¥
                        state.stage2K = k;
                        state.stage2KInv = kInv;
                    }
                    attempts++;
                }
                
                // ìœ íš¨í•œ ì¡°í•©ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ê°’ ì‚¬ìš©
                if (!foundValidPair) {
                    k = 1;
                    kInv = 6;
                    state.stage2K = k;
                    state.stage2KInv = kInv;
                    // ê¸°ë³¸ê°’ìœ¼ë¡œ ë°°ì¹˜
                    const propCandidates = [];
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        const y = k * x;
                        if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                            propCandidates.push([x, y]);
                        }
                    }
                    const shuffledProp = propCandidates.sort(() => Math.random() - 0.5);
                    for (let i = 0; i < 2 && i < shuffledProp.length; i++) {
                        const [x, y] = shuffledProp[i];
                        state.mines.add(toKey(x, y));
                    }
                    
                    const invCandidates = [];
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        if (x === 0) continue;
                        const y = kInv / x;
                        if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                            const key = toKey(x, y);
                            if (!state.mines.has(key)) {
                                invCandidates.push([x, y]);
                            }
                        }
                    }
                    const shuffledInv = invCandidates.sort(() => Math.random() - 0.5);
                    for (let i = 0; i < 2 && i < shuffledInv.length; i++) {
                        const [x, y] = shuffledInv[i];
                        state.mines.add(toKey(x, y));
                    }
                }
                
                // 3. ì¶• ìœ„ì— 1ê°œ ë°°ì¹˜ (xì¶• ë˜ëŠ” yì¶•)
                const onXAxis = Math.random() < 0.5;
                let axisPlaced = false;
                
                if (onXAxis) {
                    // xì¶• ìœ„ (y = 0) - ì›ì  ì œì™¸
                    const xValues = [];
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        if (x !== 0 || !state.mines.has(toKey(0, 0))) {
                            xValues.push(x);
                        }
                    }
                    const shuffled = xValues.sort(() => Math.random() - 0.5);
                    for (let x of shuffled) {
                        const key = toKey(x, 0);
                        if (!state.mines.has(key)) {
                            state.mines.add(key);
                            axisPlaced = true;
                            break;
                        }
                    }
                } else {
                    // yì¶• ìœ„ (x = 0) - ì›ì  ì œì™¸
                    const yValues = [];
                    for (let y = GRID_MIN; y <= GRID_MAX; y++) {
                        if (y !== 0) {
                            yValues.push(y);
                        }
                    }
                    const shuffled = yValues.sort(() => Math.random() - 0.5);
                    for (let y of shuffled) {
                        const key = toKey(0, y);
                        if (!state.mines.has(key)) {
                            state.mines.add(key);
                            axisPlaced = true;
                            break;
                        }
                    }
                }
                
                // ì¶• ìœ„ì— ë°°ì¹˜ ì‹¤íŒ¨ ì‹œ ì„ì˜ë¡œ ë°°ì¹˜
                if (!axisPlaced) {
                    for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                        const key = toKey(x, 0);
                        if (!state.mines.has(key)) {
                            state.mines.add(key);
                            break;
                        }
                    }
                }
                
                updateMineDisplay();
                updateMinesPreview();
            }
            
            // ì§€ë¢° í‘œì‹œ ì—…ë°ì´íŠ¸ (íŒíŠ¸ìš©ìœ¼ë¡œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
            function updateMineDisplay() {
                elements.mines.innerHTML = '';
            }
            
            // ì§€ë¢° ë¯¸ë¦¬ë³´ê¸° ìƒì„± ë° ì—…ë°ì´íŠ¸
            function updateMinesPreview() {
                // ê¸°ì¡´ ë¯¸ë¦¬ë³´ê¸° ì™„ì „ ì œê±° (stage1ê³¼ì˜ ì—°ë™ì„± ì œê±°)
                if (elements.minesPreview) {
                    elements.minesPreview.remove();
                    elements.minesPreview = null;
                }
                // DOMì—ì„œë„ ëª¨ë“  ë¯¸ë¦¬ë³´ê¸° ì œê±°
                const existingPreviews = document.querySelectorAll('#minesPreview');
                existingPreviews.forEach(preview => preview.remove());
                
                // stage2ì—ì„œëŠ” ì§€ë¢°ê°€ ë°°ì¹˜ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìƒì„±í•˜ì§€ ì•ŠìŒ
                if (state.mines.size === 0 && state.hits.size === 0) {
                    return;
                }
                
                // í—¤ë”ì— ë¯¸ë¦¬ë³´ê¸° ì¶”ê°€
                const preview = document.createElement('div');
                preview.className = 'mines-preview';
                preview.id = 'minesPreview';
                
                // stage2ì—ì„œëŠ” ì •í™•íˆ 4ê°œì˜ ì§€ë¢°ë§Œ í‘œì‹œ (stage1ê³¼ì˜ ì—°ë™ì„± ì™„ì „ ì œê±°)
                // state.minesì—ì„œë§Œ ì§€ë¢°ë¥¼ ê°€ì ¸ì˜´ (stage2ì˜ ì§€ë¢°ë§Œ, ì°¾ì€ ì§€ë¢°ëŠ” ì œì™¸)
                const allMines = [];
                state.mines.forEach(key => {
                    const [x, y] = fromKey(key);
                    allMines.push([x, y]);
                });
                
                // stage2ì—ì„œëŠ” ì •í™•íˆ 4ê°œë§Œ í‘œì‹œ
                if (allMines.length > 4) {
                    // ì¢Œí‘œ ìˆœì„œëŒ€ë¡œ ì •ë ¬ í›„ ì²˜ìŒ 4ê°œë§Œ ì‚¬ìš©
                allMines.sort((a, b) => {
                    if (a[0] !== b[0]) {
                            return b[0] - a[0]; // xì¢Œí‘œ ë‚´ë¦¼ì°¨ìˆœ
                    }
                        return b[1] - a[1]; // yì¢Œí‘œ ë‚´ë¦¼ì°¨ìˆœ
                    });
                    allMines.splice(4);
                } else {
                    // ì¢Œí‘œ ìˆœì„œëŒ€ë¡œ ì •ë ¬ (xì¢Œí‘œ ìš°ì„ , ê°™ìœ¼ë©´ yì¢Œí‘œ) - ì˜¤ë¥¸ìª½ë¶€í„° ìˆœì„œëŒ€ë¡œ
                    allMines.sort((a, b) => {
                        if (a[0] !== b[0]) {
                            return b[0] - a[0]; // xì¢Œí‘œ ë‚´ë¦¼ì°¨ìˆœ
                        }
                        return b[1] - a[1]; // yì¢Œí‘œ ë‚´ë¦¼ì°¨ìˆœ
                });
                }
                
                allMines.forEach(([x, y], index) => {
                    const icon = document.createElement('div');
                    icon.className = 'mine-icon';
                    icon.dataset.x = x;
                    icon.dataset.y = y;
                    icon.textContent = 'ğŸ’£';
                    icon.id = `mine-preview-${x}-${y}`;
                    
                    // ì°¾ì€ ì§€ë¢°ëŠ” ì²´í¬ í‘œì‹œí•˜ì§€ ì•ŠìŒ (updateMinesPreviewFoundì—ì„œ ì²˜ë¦¬)
                    
                    preview.appendChild(icon);
                });
                
                // ì¢Œì¸¡ íŒ¨ë„ì˜ ê²Œì„ì‹œì‘ ë²„íŠ¼ ìœ„ì— ë°°ì¹˜
                const panel = document.querySelector('.panel');
                const startBtn = document.getElementById('startBtn');
                if (startBtn && startBtn.parentElement) {
                    // ê¸°ì¡´ ë¯¸ë¦¬ë³´ê¸° ì œê±° (ìˆë‹¤ë©´)
                    const existingPreview = panel.querySelector('#minesPreview');
                    if (existingPreview) {
                        existingPreview.remove();
                    }
                    panel.insertBefore(preview, startBtn);
                } else {
                    // fallback: íŒ¨ë„ì— ì¶”ê°€
                    panel.insertBefore(preview, panel.firstChild);
                }
                elements.minesPreview = preview;
                
                // ì°¾ì€ ì§€ë¢°ë¥¼ ìˆœì„œëŒ€ë¡œ ì²´í¬
                updateMinesPreviewFound();
            }
            
            // ì°¾ì€ ì§€ë¢°ë¥¼ ì˜¤ë¥¸ìª½ë¶€í„° ìˆœì„œëŒ€ë¡œ ì²´í¬ (í™”ë©´ ìˆœì„œëŒ€ë¡œ)
            function updateMinesPreviewFound() {
                if (!elements.minesPreview) {
                    // ë¯¸ë¦¬ë³´ê¸°ê°€ ì—†ìœ¼ë©´ ë‹¤ì‹œ ìƒì„±
                    updateMinesPreview();
                    return;
                }
                
                // ëª¨ë“  ì§€ë¢° ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸° (DOM ìˆœì„œëŒ€ë¡œ = í™”ë©´ì— í‘œì‹œëœ ìˆœì„œëŒ€ë¡œ)
                const allIcons = Array.from(elements.minesPreview.querySelectorAll('.mine-icon'));
                
                // ëª¨ë“  ì•„ì´ì½˜ì˜ found í´ë˜ìŠ¤ ì œê±°
                allIcons.forEach(icon => {
                    icon.classList.remove('found');
                });
                
                // í™”ë©´ ìˆœì„œëŒ€ë¡œ(ì˜¤ë¥¸ìª½ë¶€í„°) ì°¾ì€ ì§€ë¢°ë“¤ì„ ì²´í¬
                let foundCount = 0;
                allIcons.forEach(icon => {
                    const x = parseInt(icon.dataset.x);
                    const y = parseInt(icon.dataset.y);
                    const key = toKey(x, y);
                    
                    // ì°¾ì€ ì§€ë¢°ì¸ ê²½ìš°, ì°¾ì€ ìˆœì„œëŒ€ë¡œ ì²´í¬
                    if (state.hits.has(key)) {
                        foundCount++;
                        // ì°¾ì€ ì§€ë¢° ê°œìˆ˜ë§Œí¼ë§Œ ì²´í¬ (ì˜¤ë¥¸ìª½ë¶€í„° ìˆœì„œëŒ€ë¡œ)
                        if (foundCount <= state.hits.size) {
                        icon.classList.add('found');
                        }
                    }
                });
            }
            
            // íŒíŠ¸ ìƒì„± í•¨ìˆ˜
            function generateHint(excludeHint = null) {
                if (state.mines.size === 0) return '';
                
                // state.minesì—ì„œ ì§ì ‘ ì§€ë¢° ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸°
                const mines = [];
                state.mines.forEach(key => {
                    const [x, y] = fromKey(key);
                    mines.push([x, y]);
                });
                
                // stage2Kì™€ stage2KInvê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ íŒíŠ¸ ìƒì„± ë¶ˆê°€
                if (state.stage2K === null && state.stage2KInv === null) {
                    return '';
                }
                
                // 1ë‹¨ê³„ íŠ¹ë³„ íŒíŠ¸ - ì‚¬ìš© ì•ˆ í•¨
                if (false) {
                    const hints = [];
                    
                    // ì¶• ìœ„ ì§€ë¢° íŒíŠ¸
                    const axisMines = mines.filter(([x, y]) => x === 0 || y === 0);
                    if (axisMines.length > 0) {
                        const hint = 'ì¶• ìœ„ì— ì§€ë¢°ê°€ 1ê°œ ìˆìŠµë‹ˆë‹¤.';
                        if (hint !== excludeHint) {
                            hints.push(hint);
                        }
                    }
                    
                    // ëª¨ë“  ì§€ë¢°ì— ëŒ€í•´
                    mines.forEach(([x, y]) => {
                        // xì¢Œí‘œ íŒíŠ¸
                        const hintX = `xì¢Œí‘œê°€ ${x}ì¸ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                        if (hintX !== excludeHint) {
                            hints.push(hintX);
                        }
                        
                        // yì¢Œí‘œ íŒíŠ¸
                        const hintY = `yì¢Œí‘œê°€ ${y}ì¸ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                        if (hintY !== excludeHint) {
                            hints.push(hintY);
                        }
                    });
                    
                    // ì¶• ìœ„ì— ì—†ëŠ” ì§€ë¢°ë“¤
                    const offAxisMines = mines.filter(([x, y]) => x !== 0 && y !== 0);
                    if (offAxisMines.length > 0) {
                        offAxisMines.forEach(([x, y]) => {
                            // x + y íŒíŠ¸
                            const sum = x + y;
                            const hint = `xì¢Œí‘œì™€ yì¢Œí‘œì˜ í•©ì´ ${sum}ì¸ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                            if (hint !== excludeHint) {
                                hints.push(hint);
                            }
                            
                            // x - y íŒíŠ¸ (ì ˆëŒ“ê°’)
                            const diff = Math.abs(x - y);
                            const hint2 = `xì¢Œí‘œì™€ yì¢Œí‘œì˜ ì°¨ê°€ ${diff}ì¸ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                            if (hint2 !== excludeHint) {
                                hints.push(hint2);
                            }
                            
                            // x / y ë¹„ìœ¨ íŒíŠ¸ (ì •ìˆ˜ì¸ ê²½ìš°ë§Œ)
                            if (y !== 0 && x % y === 0) {
                                const ratio = x / y;
                                const hint3 = ratio === 1 
                                    ? `xì¢Œí‘œì™€ yì¢Œí‘œì˜ ê°’ì´ ê°™ì€ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`
                                    : `xì¢Œí‘œëŠ” yì¢Œí‘œì˜ ${ratio}ë°°ì¸ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                                if (hint3 !== excludeHint) {
                                    hints.push(hint3);
                                }
                            } else if (x !== 0 && y % x === 0) {
                                const ratio = y / x;
                                const hint3 = ratio === 1 
                                    ? `xì¢Œí‘œì™€ yì¢Œí‘œì˜ ê°’ì´ ê°™ì€ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`
                                    : `yì¢Œí‘œëŠ” xì¢Œí‘œì˜ ${ratio}ë°°ì¸ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                                if (hint3 !== excludeHint) {
                                    hints.push(hint3);
                                }
                            }
                            
                            // ì ˆëŒ“ê°’ íŒíŠ¸
                            const absX = Math.abs(x);
                            const absY = Math.abs(y);
                            if (absX === absY) {
                                const hint4 = `xì¢Œí‘œì™€ yì¢Œí‘œì˜ ì ˆëŒ“ê°’ì´ ê°™ì€ ì§€ë¢°ê°€ ìˆìŠµë‹ˆë‹¤.`;
                                if (hint4 !== excludeHint) {
                                    hints.push(hint4);
                                }
                            }
                        });
                    }
                    
                    if (hints.length === 0) {
                        const defaultHint = 'ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” -5~5 ë²”ìœ„ì˜ ê²©ìì ì— ìˆìŠµë‹ˆë‹¤.';
                        return defaultHint !== excludeHint ? defaultHint : '';
                    }
                    
                    return hints[Math.floor(Math.random() * hints.length)];
                }
                
                // 2ë‹¨ê³„ íŠ¹ë³„ íŒíŠ¸
                {
                    const hints = [];
                    
                    // ì²« ë²ˆì§¸ íŒíŠ¸
                    if (!state.firstHintShown) {
                        const firstHint = 'ì§€ë¢°ëŠ” í•˜ë‚˜ì˜ ì •ë¹„ë¡€ ê´€ê³„ ê·¸ë˜í”„ ìœ„ì— 2ê°œ, í•˜ë‚˜ì˜ ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ì— 2ê°œ ìˆë‹¤.';
                        if (firstHint !== excludeHint && !state.shownHints.has(firstHint)) {
                            state.firstHintShown = true;
                            return firstHint;
                        }
                    }
                    
                    // ì •ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ ì§€ë¢° ì°¾ê¸°
                    const propMines = [];
                    const invMines = [];
                    
                    if (state.stage2K !== null) {
                        mines.forEach(([x, y]) => {
                            // ì •ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ì¸ì§€ í™•ì¸: y = kx
                            if (Math.abs(y - state.stage2K * x) < 0.001) {
                                propMines.push([x, y]);
                            }
                        });
                    }
                    
                    if (state.stage2KInv !== null) {
                        mines.forEach(([x, y]) => {
                            // ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ì¸ì§€ í™•ì¸: y = k/x
                            if (x !== 0 && Math.abs(y - state.stage2KInv / x) < 0.001) {
                                invMines.push([x, y]);
                            }
                        });
                    }
                    
                    // ëª¨ë“  ì§€ë¢° ì¢Œí‘œ Set ìƒì„± (ë¹ ë¥¸ ê²€ìƒ‰ì„ ìœ„í•´)
                    const allMinesSet = new Set();
                    mines.forEach(([x, y]) => {
                        allMinesSet.add(toKey(x, y));
                    });
                    state.hits.forEach(key => {
                        const [x, y] = fromKey(key);
                        allMinesSet.add(toKey(x, y));
                    });
                    
                    // 1. ì •ë¹„ë¡€ ê·¸ë˜í”„ ì‚¬ë¶„ë©´ íŒíŠ¸
                    if (state.stage2K !== null && propMines.length > 0) {
                        // ì •ë¹„ë¡€ ê·¸ë˜í”„ y = kxê°€ ì§€ë‚˜ëŠ” ì‚¬ë¶„ë©´ ì°¾ê¸°
                        const quadrants = new Set();
                        // ê·¸ë˜í”„ ìœ„ì˜ ì—¬ëŸ¬ ì ì„ í™•ì¸í•˜ì—¬ ì§€ë‚˜ëŠ” ì‚¬ë¶„ë©´ íŒë‹¨
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            const y = state.stage2K * x;
                            if (y >= GRID_MIN && y <= GRID_MAX) {
                                if (x > 0 && y > 0) quadrants.add(1);
                                else if (x < 0 && y > 0) quadrants.add(2);
                                else if (x < 0 && y < 0) quadrants.add(3);
                                else if (x > 0 && y < 0) quadrants.add(4);
                            }
                        }
                        
                        quadrants.forEach(quad => {
                            const hint = `ì§€ë¢°ê°€ ìˆëŠ” ì •ë¹„ë¡€ ê´€ê³„ì˜ ê·¸ë˜í”„ëŠ” ì œ${quad}ì‚¬ë¶„ë©´ì„ ì§€ë‚œë‹¤.`;
                            if (hint !== excludeHint && !state.shownHints.has(hint)) {
                                hints.push(hint);
                            }
                        });
                            }
                            
                    // 2. ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ì‚¬ë¶„ë©´ íŒíŠ¸
                    if (state.stage2KInv !== null && invMines.length > 0) {
                        // ë°˜ë¹„ë¡€ ê·¸ë˜í”„ y = k/xê°€ ì§€ë‚˜ëŠ” ì‚¬ë¶„ë©´ ì°¾ê¸°
                        const quadrants = new Set();
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            if (x === 0) continue;
                            const y = state.stage2KInv / x;
                            if (y >= GRID_MIN && y <= GRID_MAX) {
                                if (x > 0 && y > 0) quadrants.add(1);
                                else if (x < 0 && y > 0) quadrants.add(2);
                                else if (x < 0 && y < 0) quadrants.add(3);
                                else if (x > 0 && y < 0) quadrants.add(4);
                            }
                        }
                        
                        quadrants.forEach(quad => {
                            const hint = `ì§€ë¢°ê°€ ìˆëŠ” ë°˜ë¹„ë¡€ ê´€ê³„ì˜ ê·¸ë˜í”„ëŠ” ì œ${quad}ì‚¬ë¶„ë©´ì„ ì§€ë‚œë‹¤.`;
                            if (hint !== excludeHint && !state.shownHints.has(hint)) {
                                hints.push(hint);
                            }
                        });
                    }
                    
                    // 3. ì •ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ ì •ìˆ˜ì  íŒíŠ¸ (ì§€ë¢°ê°€ ì•„ë‹Œ ì )
                    if (state.stage2K !== null && propMines.length > 0) {
                        const nonMinePoints = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            const y = state.stage2K * x;
                            if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                const key = toKey(x, y);
                                // ì§€ë¢°ê°€ ì•„ë‹Œ ì ë§Œ ì¶”ê°€
                                if (!allMinesSet.has(key)) {
                                    nonMinePoints.push([x, y]);
                                }
                            }
                            }
                            
                        // ì§€ë¢°ê°€ ì•„ë‹Œ ì ë“¤ì„ íŒíŠ¸ í›„ë³´ë¡œ ì—¬ëŸ¬ ê°œ ì¶”ê°€ (ì¤‘ë³µ íŒíŠ¸ ë°©ì§€ & ë‹¤ì–‘ì„± í™•ë³´)
                        // - ê°€ëŠ¥í•œ í•œ ë‹¤ì–‘í•œ ì ì´ ë‚˜ì˜¤ë„ë¡ ì „ì²´ í›„ë³´ë¥¼ ë„£ê³ , ì•„ë˜ì—ì„œ ì•„ì§ ì•ˆ ë‚˜ì˜¨ íŒíŠ¸ë§Œ ëœë¤ ì„ íƒ
                        if (nonMinePoints.length > 0) {
                            // ì„ì–´ì„œ í›„ë³´ ë‹¤ì–‘ì„± í™•ë³´
                            const shuffled = nonMinePoints.sort(() => Math.random() - 0.5);
                            shuffled.forEach(([px, py]) => {
                                const hint = `ì§€ë¢°ê°€ ìˆëŠ” ì •ë¹„ë¡€ ê´€ê³„ì˜ ê·¸ë˜í”„ëŠ” ì  (${px},${py})ì„ ì§€ë‚œë‹¤.`;
                                if (hint !== excludeHint && !state.shownHints.has(hint)) {
                                    hints.push(hint);
                                }
                            });
                        }
                            }
                            
                    // 4. ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ ì •ìˆ˜ì  íŒíŠ¸ (ì§€ë¢°ê°€ ì•„ë‹Œ ì )
                    if (state.stage2KInv !== null && invMines.length > 0) {
                        const nonMinePoints = [];
                        for (let x = GRID_MIN; x <= GRID_MAX; x++) {
                            if (x === 0) continue;
                            const y = state.stage2KInv / x;
                            if (isInt(y) && y >= GRID_MIN && y <= GRID_MAX) {
                                const key = toKey(x, y);
                                // ì§€ë¢°ê°€ ì•„ë‹Œ ì ë§Œ ì¶”ê°€
                                if (!allMinesSet.has(key)) {
                                    nonMinePoints.push([x, y]);
                                }
                            }
                        }
                        
                        // ì§€ë¢°ê°€ ì•„ë‹Œ ì ë“¤ì„ íŒíŠ¸ í›„ë³´ë¡œ ì—¬ëŸ¬ ê°œ ì¶”ê°€ (ì¤‘ë³µ íŒíŠ¸ ë°©ì§€ & ë‹¤ì–‘ì„± í™•ë³´)
                        if (nonMinePoints.length > 0) {
                            const shuffled = nonMinePoints.sort(() => Math.random() - 0.5);
                            shuffled.forEach(([px, py]) => {
                                const hint = `ì§€ë¢°ê°€ ìˆëŠ” ë°˜ë¹„ë¡€ ê´€ê³„ì˜ ê·¸ë˜í”„ëŠ” ì  (${px},${py})ì„ ì§€ë‚œë‹¤.`;
                                if (hint !== excludeHint && !state.shownHints.has(hint)) {
                                    hints.push(hint);
                                }
                            });
                        }
                    }
                    
                    if (hints.length === 0) {
                        // íŒíŠ¸ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ ë°˜í™˜ (ê¸°ë³¸ íŒíŠ¸ ì œê±°)
                        return '';
                    }
                    
                    // ì´ë¯¸ ë‚˜ì˜¨ íŒíŠ¸ëŠ” ì ˆëŒ€ ì œê³µí•˜ì§€ ì•ŠìŒ: ë‚¨ì€ í›„ë³´ ì¤‘ì—ì„œë§Œ ëœë¤ ì„ íƒ
                    // (ìœ„ì—ì„œ ì´ë¯¸ shownHintsë¥¼ ì œì™¸í•˜ê³  push í–ˆê¸° ë•Œë¬¸ì—, ì—¬ê¸°ì„œëŠ” hintsë§Œ ë³´ë©´ ë¨)
                    return hints[Math.floor(Math.random() * hints.length)];
                }
                
                // 2ë‹¨ê³„ì—ì„œëŠ” ì—¬ê¸°ê¹Œì§€ ì‹¤í–‰
                return '';
                
                // 3ë‹¨ê³„ íŒíŠ¸ - ì‚¬ìš© ì•ˆ í•¨
                const hints = [];
                
                // 1. ì‚¬ë¶„ë©´ íŒíŠ¸
                const quadrants = [0, 0, 0, 0]; // 1, 2, 3, 4ì‚¬ë¶„ë©´
                mines.forEach(([x, y]) => {
                    if (x > 0 && y > 0) quadrants[0]++; // 1ì‚¬ë¶„ë©´
                    else if (x < 0 && y > 0) quadrants[1]++; // 2ì‚¬ë¶„ë©´
                    else if (x < 0 && y < 0) quadrants[2]++; // 3ì‚¬ë¶„ë©´
                    else if (x > 0 && y < 0) quadrants[3]++; // 4ì‚¬ë¶„ë©´
                    // x === 0 ë˜ëŠ” y === 0ì¸ ê²½ìš°ëŠ” ì‚¬ë¶„ë©´ì— í¬í•¨ë˜ì§€ ì•ŠìŒ (ì •ìƒ)
                });
                
                const nonZeroQuads = quadrants.map((count, idx) => ({quad: idx+1, count})).filter(q => q.count > 0);
                nonZeroQuads.forEach(quad => {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” ${quad.quad}ì‚¬ë¶„ë©´ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                });
                
                // 2. x, y ë¶€í˜¸ì— ëŒ€í•œ íŒíŠ¸
                const positiveX = mines.filter(([x, y]) => x > 0).length;
                const negativeX = mines.filter(([x, y]) => x < 0).length;
                const zeroX = mines.filter(([x, y]) => x === 0).length;
                const positiveY = mines.filter(([x, y]) => y > 0).length;
                const negativeY = mines.filter(([x, y]) => y < 0).length;
                const zeroY = mines.filter(([x, y]) => y === 0).length;
                
                if (positiveX > 0) {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” xê°€ ì–‘ìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                if (negativeX > 0) {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” xê°€ ìŒìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                if (zeroX > 0) {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” xê°€ 0ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                if (positiveY > 0) {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” yê°€ ì–‘ìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                if (negativeY > 0) {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” yê°€ ìŒìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                if (zeroY > 0) {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” yê°€ 0ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                
                // ì›ì ì€ íŠ¹ë³„íˆ ì²˜ë¦¬
                const atOrigin = mines.filter(([x, y]) => x === 0 && y === 0).length;
                if (atOrigin > 0) {
                    const hint = 'ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” ì›ì (0, 0)ì— ìˆìŠµë‹ˆë‹¤.';
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                }
                
                // 3. x, y ì¢Œí‘œ ê°’ì— ëŒ€í•œ íŒíŠ¸
                const xValues = new Set();
                const yValues = new Set();
                mines.forEach(([x, y]) => {
                    xValues.add(x);
                    yValues.add(y);
                });
                
                // xì¢Œí‘œ ê°’ íŒíŠ¸
                xValues.forEach(x => {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ì˜ xì¢Œí‘œëŠ” ${x}ì…ë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                });
                
                // yì¢Œí‘œ ê°’ íŒíŠ¸
                yValues.forEach(y => {
                    const hint = `ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ì˜ yì¢Œí‘œëŠ” ${y}ì…ë‹ˆë‹¤.`;
                    if (hint !== excludeHint) {
                        hints.push(hint);
                    }
                });
                
                if (hints.length === 0) {
                    // ë‹¤ë¥¸ íŒíŠ¸ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ íŒíŠ¸ ë°˜í™˜ (í˜„ì¬ íŒíŠ¸ì™€ ë‹¤ë¥´ë©´)
                    const defaultHint = 'ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” -5~5 ë²”ìœ„ì˜ ê²©ìì ì— ìˆìŠµë‹ˆë‹¤.';
                    return defaultHint !== excludeHint ? defaultHint : '';
                }
                
                return hints[Math.floor(Math.random() * hints.length)];
            }
            
            // íŒíŠ¸ íŒì—… í‘œì‹œ
            function showAutoHintPopup(message) {
                // ê¸°ì¡´ íŒì—… ì œê±°
                const existingPopup = document.querySelector('.hint-popup');
                if (existingPopup) {
                    existingPopup.remove();
                }
                
                const popup = document.createElement('div');
                popup.className = 'hint-popup';
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'hint-popup-close';
                closeBtn.textContent = 'Ã—';
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = 'font-size: 16px; margin-top: 10px; color: #333;';
                
                const title = document.createElement('strong');
                title.style.color = '#667eea';
                title.textContent = 'ğŸ’¡ íŒíŠ¸';
                
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = 'margin-top: 10px; font-size: 18px;';
                messageDiv.textContent = message;
                
                contentDiv.appendChild(title);
                contentDiv.appendChild(messageDiv);
                
                popup.appendChild(closeBtn);
                popup.appendChild(contentDiv);
                document.body.appendChild(popup);
                
                // ë‹«ê¸° í•¨ìˆ˜
                const closePopup = () => {
                    popup.style.animation = 'popupAppear 0.3s ease-out reverse';
                    setTimeout(() => {
                        if (popup.parentElement) {
                            popup.remove();
                        }
                    }, 300);
                };
                
                // 5ì´ˆ í›„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì§€ê¸°
                const autoClose = setTimeout(() => {
                    if (popup.parentElement) {
                        closePopup();
                    }
                }, 5000);
                
                // ë‹«ê¸° ë²„íŠ¼ í´ë¦­
                closeBtn.addEventListener('click', () => {
                    clearTimeout(autoClose);
                    closePopup();
                });
                
                // íŒì—… í´ë¦­ ì‹œ ë‹«ê¸°
                popup.addEventListener('click', (e) => {
                    if (e.target === popup) {
                        clearTimeout(autoClose);
                        closePopup();
                    }
                });
            }
            
            // ê²Œì„ ì„¤ëª… íŒì—… í‘œì‹œ
            function showIntroPopup() {
                const popup = document.createElement('div');
                popup.className = 'intro-popup';
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'intro-popup-close';
                closeBtn.textContent = 'Ã—';
                
                const title = document.createElement('h2');
                title.textContent = 'ê²Œì„ ì„¤ëª…';
                
                const content = document.createElement('div');
                content.className = 'intro-popup-content';
                
                // ê²Œì„ ëª©í‘œ
                const goalP = document.createElement('p');
                const goalStrong = document.createElement('strong');
                goalStrong.textContent = 'ê²Œì„ ëª©í‘œ:';
                goalP.appendChild(goalStrong);
                goalP.appendChild(document.createTextNode('\nì¢Œí‘œí‰ë©´ ìœ„ì—ì„œ x, y ì¢Œí‘œê°€ ëª¨ë‘ ì •ìˆ˜ì¸ ê²©ìì  ìœ„ì— ì§€ë¢°ê°€ 5ê°œ ìˆ¨ì–´ ìˆìŠµë‹ˆë‹¤. ëª¨ë“  ì§€ë¢°ë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤!'));
                
                // ê²Œì„ ë°©ë²•
                const methodP = document.createElement('p');
                const methodStrong = document.createElement('strong');
                methodStrong.textContent = 'ê²Œì„ ë°©ë²•:';
                methodP.appendChild(methodStrong);
                methodP.appendChild(document.createTextNode('\nì ì´ë‚˜ ì •ë¹„ë¡€ì‹, ë°˜ë¹„ë¡€ì‹ì„ ì…ë ¥í•˜ì—¬ í•´ë‹¹ ìœ„ì¹˜ì— ì§€ë¢°ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.'));
                
                const methodUl = document.createElement('ul');
                const methodItems = [
                    { text: 'ì : ', codes: ['(3, -2)', '(-1, 4)'] },
                    { text: 'ì •ë¹„ë¡€: ', codes: ['y = x', 'y = 2x', 'y = (-1/2)x', 'y = (3/2)x'] },
                    { text: 'ë°˜ë¹„ë¡€: ', codes: ['y = 6/x', 'y = -2/x'] }
                ];
                methodItems.forEach(item => {
                    const li = document.createElement('li');
                    li.appendChild(document.createTextNode(item.text));
                    item.codes.forEach((code, index) => {
                        const codeEl = document.createElement('code');
                        codeEl.textContent = code;
                        li.appendChild(codeEl);
                        if (index < item.codes.length - 1) {
                            li.appendChild(document.createTextNode(', '));
                        }
                    });
                    methodUl.appendChild(li);
                });
                
                // ê²Œì„ íŒ
                const tipP = document.createElement('p');
                const tipStrong = document.createElement('strong');
                tipStrong.textContent = 'ê²Œì„ íŒ:';
                tipP.appendChild(tipStrong);
                
                const tipUl = document.createElement('ul');
                const tipItems = [
                    'ì •ë¹„ë¡€/ë°˜ë¹„ë¡€ì‹ì€ í•´ë‹¹ ì‹ ìœ„ì˜ ëª¨ë“  ê²©ìì ì„ ìŠ¤ìº”í•©ë‹ˆë‹¤!',
                    'ì§€ë¢°ë¥¼ ì°¾ìœ¼ë©´ +10ì , ì‹œë„í•  ë•Œë§ˆë‹¤ -1ì ì…ë‹ˆë‹¤.',
                    'ì‹œë„ íšŸìˆ˜ê°€ í™€ìˆ˜ë²ˆì¼ ë•Œë§ˆë‹¤ ìë™ìœ¼ë¡œ íŒíŠ¸ê°€ ì œê³µë©ë‹ˆë‹¤!'
                ];
                tipItems.forEach((text, index) => {
                    const li = document.createElement('li');
                    if (index === 2) {
                        const strong = document.createElement('strong');
                        strong.style.color = '#e91e63';
                        strong.textContent = text;
                        li.appendChild(strong);
                    } else {
                        li.textContent = text;
                    }
                    tipUl.appendChild(li);
                });
                
                // ì‹œì‘ ë²„íŠ¼
                const buttonP = document.createElement('p');
                buttonP.style.cssText = 'text-align: center; margin-top: 20px;';
                const startBtn = document.createElement('button');
                startBtn.style.cssText = 'padding: 12px 30px; font-size: 16px;';
                startBtn.textContent = 'ê²Œì„ ì‹œì‘í•˜ê¸°';
                buttonP.appendChild(startBtn);
                
                content.appendChild(goalP);
                content.appendChild(methodP);
                content.appendChild(methodUl);
                content.appendChild(tipP);
                content.appendChild(tipUl);
                content.appendChild(buttonP);
                
                popup.appendChild(closeBtn);
                popup.appendChild(title);
                popup.appendChild(content);
                document.body.appendChild(popup);
                
                // ë‹«ê¸° í•¨ìˆ˜
                const closePopup = () => {
                    popup.style.animation = 'popupAppear 0.3s ease-out reverse';
                    setTimeout(() => {
                        if (popup.parentElement) {
                            popup.remove();
                        }
                    }, 300);
                };
                
                // ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
                closeBtn.addEventListener('click', closePopup);
                
                // ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì‹œ ë‹«ê¸°
                startBtn.addEventListener('click', closePopup);
            }
            
            // ì  ì²´í¬
            function checkPoint(x, y) {
                const key = toKey(x, y);
                
                if (state.tried.has(key)) {
                    elements.inputError.classList.add('show');
                    return;
                }
                
                state.tried.add(key);
                state.tries++;
                state.score -= 1; // ì‹œë„ íšŸìˆ˜ë§ˆë‹¤ -1ì 
                
                if (state.mines.has(key)) {
                    state.mines.delete(key);
                    state.hits.add(key);
                    state.found++;
                    state.score += 10; // ì§€ë¢°ë¥¼ ì°¾ìœ¼ë©´ +10ì 
                    
                    // ì´ë¯¸ ê·¸ë ¤ì§„ ë§ˆì»¤ê°€ ì—†ì„ ë•Œë§Œ ì¶”ê°€
                    const pointId = `point-${x}-${y}-hit`;
                    if (!document.getElementById(pointId)) {
                        const pointElement = drawPoint(x, y, 'hit');
                        elements.marks.appendChild(pointElement);
                    }
                    
                    // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸ - ì™¼ìª½ë¶€í„° ìˆœì„œëŒ€ë¡œ ì²´í¬
                    updateMinesPreviewFound();
                    
                    // ì§€ë¢° ë°œê²¬ (ë¡œê·¸ ì œê±°ë¨)
                    
                    // íŒíŠ¸ ëª©ë¡ ì—…ë°ì´íŠ¸
                    updateHintsList();
                    
                    if (state.mines.size === 0) {
                        endGame();
                    }
                } else {
                    state.score -= 1;
                    
                    // ì´ë¯¸ ê·¸ë ¤ì§„ ë§ˆì»¤ê°€ ì—†ì„ ë•Œë§Œ ì¶”ê°€
                    const pointId = `point-${x}-${y}-miss`;
                    if (!document.getElementById(pointId)) {
                        const pointElement = drawPoint(x, y, 'miss');
                        elements.marks.appendChild(pointElement);
                    }
                    
                    // ì§€ë¢° ì—†ìŒ (ë¡œê·¸ ì œê±°ë¨)
                }
                // ì‹¤íŒ¨ ì‹œ ì¶”ê°€ ì ìˆ˜ ì°¨ê° ì—†ìŒ (ì´ë¯¸ ì‹œë„ ì‹œ -1ì  ì°¨ê°ë¨)
                
                updateUI();
                updateMineDisplay();
            }
            
            // ì •ë¹„ë¡€ ê·¸ë˜í”„ ê·¸ë¦¬ê¸° (ì§€ë¢° ìŠ¤ìº” ì—†ìŒ)
            function scanProportional(k) {
                // ì„  ê·¸ë¦¬ê¸°ë§Œ ìˆ˜í–‰ (ê¸°ì¡´ ê·¸ë˜í”„ëŠ” ìœ ì§€)
                const lineData = drawLine(x => k * x, 'proportional', k);
                const svgNS = 'http://www.w3.org/2000/svg';
                // elements.lines.innerHTML = ''; ì œê±° - ê·¸ë˜í”„ë¥¼ ì§€ìš°ì§€ ì•ŠìŒ
                
                const path = document.createElementNS(svgNS, 'path');
                path.setAttribute('d', lineData.path);
                path.setAttribute('stroke', '#667eea');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('opacity', '0.6');
                elements.lines.appendChild(path);
                
                lineData.points.forEach(([x, y]) => {
                    const [sx, sy] = gridToSvg(x, y);
                    const rect = document.createElementNS(svgNS, 'rect');
                    rect.setAttribute('x', sx - 4);
                    rect.setAttribute('y', sy - 4);
                    rect.setAttribute('width', '8');
                    rect.setAttribute('height', '8');
                    rect.setAttribute('fill', '#667eea');
                    rect.setAttribute('opacity', '0.5');
                    elements.lines.appendChild(rect);
                });
                
                // ì‹œë„ íšŸìˆ˜ ì¦ê°€ (íŒíŠ¸ í‘œì‹œë¥¼ ìœ„í•´)
                state.tries++;
                updateUI();
            }
            
            // ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ê·¸ë¦¬ê¸° (ì§€ë¢° ìŠ¤ìº” ì—†ìŒ)
            function scanInverse(k) {
                // ì„  ê·¸ë¦¬ê¸°ë§Œ ìˆ˜í–‰ (ê¸°ì¡´ ê·¸ë˜í”„ëŠ” ìœ ì§€)
                const lineData = drawLine(x => k / x, 'inverse', k);
                const svgNS = 'http://www.w3.org/2000/svg';
                // elements.lines.innerHTML = ''; ì œê±° - ê·¸ë˜í”„ë¥¼ ì§€ìš°ì§€ ì•ŠìŒ
                
                const path = document.createElementNS(svgNS, 'path');
                path.setAttribute('d', lineData.path);
                path.setAttribute('stroke', '#667eea');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('opacity', '0.6');
                path.setAttribute('stroke-linecap', 'round');
                elements.lines.appendChild(path);
                
                lineData.points.forEach(([x, y]) => {
                    const [sx, sy] = gridToSvg(x, y);
                    const rect = document.createElementNS(svgNS, 'rect');
                    rect.setAttribute('x', sx - 4);
                    rect.setAttribute('y', sy - 4);
                    rect.setAttribute('width', '8');
                    rect.setAttribute('height', '8');
                    rect.setAttribute('fill', '#667eea');
                    rect.setAttribute('opacity', '0.5');
                    elements.lines.appendChild(rect);
                });
                
                // ì‹œë„ íšŸìˆ˜ ì¦ê°€ (íŒíŠ¸ í‘œì‹œë¥¼ ìœ„í•´)
                state.tries++;
                updateUI();
            }
            
            // ë‹¨ê³„ í‘œì‹œ ì—…ë°ì´íŠ¸
            function updateStageIndicator() {
                const stageItems = elements.stageIndicator.querySelectorAll('.stage-item');
                const connectors = elements.stageIndicator.querySelectorAll('.stage-connector');
                
                stageItems.forEach((item, index) => {
                    const stageNum = parseInt(item.dataset.stage);
                    item.classList.remove('active', 'completed');
                    
                    if (stageNum === 2) {
                        item.classList.add('active');
                    } else if (stageNum < 2) {
                        item.classList.add('completed');
                    }
                });
                
                connectors.forEach((connector, index) => {
                    connector.classList.remove('completed');
                    if (index + 1 < 2) {
                        connector.classList.add('completed');
                    }
                });
                
                // ë‹¨ê³„ ì„¤ëª… ì—…ë°ì´íŠ¸
                const stageDescription = document.getElementById('stageDescription');
                if (stageDescription) {
                        stageDescription.textContent = 'ì •ë¹„ë¡€ì™€ ë°˜ë¹„ë¡€ ê´€ê³„ ê·¸ë˜í”„ë¥¼ ì´ìš©í•˜ì—¬ ì¢Œí‘œí‰ë©´ ìœ„ ì§€ë¢°ë¥¼ ì°¾ì•„ë¼!';
                }
            }
            
            // UI ì—…ë°ì´íŠ¸
            function updateUI() {
                elements.minesLeft.textContent = state.mines.size;
                elements.tries.textContent = state.tries;
                elements.hits.textContent = state.found;
                elements.score.textContent = state.score;
                updateStageIndicator();
                
                // ì‹œë„ íšŸìˆ˜ê°€ í™€ìˆ˜ë²ˆì¼ ë•Œ íŒíŠ¸ íŒì—… í‘œì‹œ ë° ì™¼ìª½ íŒ¨ë„ì— ì¶”ê°€
                if (state.tries > 0 && state.tries % 2 === 1 && state.lastHintTries !== state.tries) {
                    let newHint = generateHint(state.currentHint);
                    // ì¤‘ë³µ ë°©ì§€: ì´ë¯¸ í‘œì‹œëœ íŒíŠ¸ëŠ” ë‹¤ì‹œ ìƒì„±
                    let attempts = 0;
                    while (newHint && newHint.trim() !== '' && state.shownHints.has(newHint) && attempts < 10) {
                        newHint = generateHint(newHint);
                        attempts++;
                    }
                    if (newHint && newHint.trim() !== '' && !state.shownHints.has(newHint)) {
                        state.currentHint = newHint; // í˜„ì¬ íŒíŠ¸ ì—…ë°ì´íŠ¸
                        state.shownHints.add(newHint); // íŒíŠ¸ í…ìŠ¤íŠ¸ ì €ì¥ (ì¤‘ë³µ ë°©ì§€)
                        state.lastHintTries = state.tries; // ë§ˆì§€ë§‰ íŒíŠ¸ í‘œì‹œ ì‹œë„ íšŸìˆ˜ ì €ì¥
                        showAutoHintPopup(newHint); // íŒì—…ìœ¼ë¡œ íŒíŠ¸ í‘œì‹œ
                        addAutoHint(newHint); // ìš°ì¸¡ íŒ¨ë„ì— íŒíŠ¸ ì¶”ê°€
                    } else {
                        // íŒíŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ê±°ë‚˜ ì´ë¯¸ í‘œì‹œëœ ê²½ìš°, ì´ë²ˆ ì‹œë„ì—ì„œëŠ” íŒíŠ¸ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                        // ë‹¤ìŒ í™€ìˆ˜ë²ˆì§¸ ì‹œë„ì—ì„œ ë‹¤ì‹œ ì‹œë„í•  ìˆ˜ ìˆë„ë¡ lastHintTriesë¥¼ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ
                        // í•˜ì§€ë§Œ ë¬´í•œ ë£¨í”„ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ìµœëŒ€ 1ë²ˆë§Œ ì¬ì‹œë„
                        if (attempts === 0 && (!newHint || newHint.trim() === '')) {
                            // íŒíŠ¸ ìƒì„± ì‹¤íŒ¨ ì‹œì—ë„ ì´ë²ˆ ì‹œë„ì—ì„œëŠ” ë” ì´ìƒ ì‹œë„í•˜ì§€ ì•ŠìŒ
                            state.lastHintTries = state.tries;
                        }
                    }
                }
            }
            
            // íŒíŠ¸ë¥¼ ìš°ì¸¡ íŒ¨ë„ì— ì¶”ê°€ (íŒíŠ¸ ìœ íš¨ì„± ê²€ì¦ í¬í•¨)
            function addAutoHint(hint) {
                // íŒíŠ¸ê°€ í˜„ì¬ ì§€ë¢° ìƒíƒœì™€ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
                if (!isHintValid(hint)) {
                    // íŒíŠ¸ê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ìƒˆë¡œìš´ íŒíŠ¸ ìƒì„±
                    const validHint = generateHint(state.currentHint);
                    if (validHint && validHint !== hint) {
                        hint = validHint;
                        state.currentHint = validHint;
                    } else {
                        // ìœ íš¨í•œ íŒíŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìœ¼ë©´ íŒíŠ¸ë¥¼ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
                        return;
                    }
                }
                
                const hintItem = document.createElement('div');
                hintItem.style.cssText = 'padding: 8px; margin: 5px 0; background: #f0f7ff; border-left: 3px solid #667eea; border-radius: 4px; font-size: 12px; cursor: pointer; user-select: none;';
                hintItem.textContent = `â€¢ ${hint}`;
                hintItem.dataset.hint = hint; // íŒíŠ¸ ì €ì¥
                
                // íŒíŠ¸ í´ë¦­ ì‹œ ì¤„ ê¸‹ê¸°/ì œê±°
                hintItem.addEventListener('click', () => {
                    if (hintItem.classList.contains('hint-crossed')) {
                        hintItem.classList.remove('hint-crossed');
                        hintItem.style.textDecoration = 'none';
                    } else {
                        hintItem.classList.add('hint-crossed');
                        hintItem.style.textDecoration = 'line-through';
                        hintItem.style.textDecorationThickness = '2px';
                        hintItem.style.textDecorationColor = '#999';
                    }
                });
                
                elements.autoHintsList.appendChild(hintItem);
                
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ì•„ë˜ë¡œ
                elements.autoHintsList.scrollTop = elements.autoHintsList.scrollHeight;
            }
            
            // íŒíŠ¸ê°€ í˜„ì¬ ì§€ë¢° ìƒíƒœì™€ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
            function isHintValid(hint) {
                if (state.mines.size === 0) return false;
                
                // state.minesì—ì„œ ì§ì ‘ ì§€ë¢° ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸°
                const mines = [];
                state.mines.forEach(key => {
                    const [x, y] = fromKey(key);
                    mines.push([x, y]);
                });
                
                // 1. ì‚¬ë¶„ë©´ íŒíŠ¸ ê²€ì¦
                const quadMatch = hint.match(/ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” (\d)ì‚¬ë¶„ë©´ì— ìˆìŠµë‹ˆë‹¤/);
                if (quadMatch) {
                    const quad = parseInt(quadMatch[1]);
                    const hasMine = mines.some(([x, y]) => {
                        if (quad === 1) return x > 0 && y > 0;
                        else if (quad === 2) return x < 0 && y > 0;
                        else if (quad === 3) return x < 0 && y < 0;
                        else if (quad === 4) return x > 0 && y < 0;
                        return false;
                    });
                    return hasMine;
                }
                
                // 2. x, y ë¶€í˜¸ íŒíŠ¸ ê²€ì¦
                if (hint.includes('xê°€ ì–‘ìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤')) {
                    const hasMine = mines.some(([x, y]) => x > 0);
                    return hasMine;
                }
                
                if (hint.includes('xê°€ ìŒìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤')) {
                    const hasMine = mines.some(([x, y]) => x < 0);
                    return hasMine;
                }
                
                if (hint.includes('xê°€ 0ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤')) {
                    const hasMine = mines.some(([x, y]) => x === 0);
                    return hasMine;
                }
                
                if (hint.includes('yê°€ ì–‘ìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤')) {
                    const hasMine = mines.some(([x, y]) => y > 0);
                    return hasMine;
                }
                
                if (hint.includes('yê°€ ìŒìˆ˜ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤')) {
                    const hasMine = mines.some(([x, y]) => y < 0);
                    return hasMine;
                }
                
                if (hint.includes('yê°€ 0ì¸ ê³³ì— ìˆìŠµë‹ˆë‹¤')) {
                    const hasMine = mines.some(([x, y]) => y === 0);
                    return hasMine;
                }
                
                // ì›ì  íŒíŠ¸ ê²€ì¦
                if (hint === 'ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” ì›ì (0, 0)ì— ìˆìŠµë‹ˆë‹¤.' || hint === 'ì›ì (0, 0)ì— ìˆìŠµë‹ˆë‹¤.') {
                    const hasMine = mines.some(([x, y]) => x === 0 && y === 0);
                    return hasMine;
                }
                
                // 3. x, y ì¢Œí‘œ ê°’ íŒíŠ¸ ê²€ì¦
                const xCoordMatch = hint.match(/ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ì˜ xì¢Œí‘œëŠ” (-?\d+)ì…ë‹ˆë‹¤/);
                if (xCoordMatch) {
                    const x = parseInt(xCoordMatch[1]);
                    const hasMine = mines.some(([mx, my]) => mx === x);
                    return hasMine;
                }
                
                const yCoordMatch = hint.match(/ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ì˜ yì¢Œí‘œëŠ” (-?\d+)ì…ë‹ˆë‹¤/);
                if (yCoordMatch) {
                    const y = parseInt(yCoordMatch[1]);
                    const hasMine = mines.some(([mx, my]) => my === y);
                    return hasMine;
                }
                
                // ê¸°ë³¸ íŒíŠ¸ëŠ” í•­ìƒ ìœ íš¨
                if (hint === 'ì•„ì§ ì°¾ì§€ ëª»í•œ ì§€ë¢°ëŠ” -5~5 ë²”ìœ„ì˜ ê²©ìì ì— ìˆìŠµë‹ˆë‹¤.' || hint === 'ì§€ë¢°ëŠ” -5~5 ë²”ìœ„ì˜ ê²©ìì ì— ìˆìŠµë‹ˆë‹¤.') {
                    return true;
                }
                
                return true; // ì•Œ ìˆ˜ ì—†ëŠ” íŒíŠ¸ í˜•ì‹ì€ ì¼ë‹¨ ìœ íš¨í•˜ë‹¤ê³  ê°„ì£¼
            }
            
            // íŒíŠ¸ ëª©ë¡ ì—…ë°ì´íŠ¸ (ì§€ë¢°ê°€ ì œê±°ë  ë•Œ í˜¸ì¶œ)
            function updateHintsList() {
                const hintItems = elements.autoHintsList.querySelectorAll('[data-hint]');
                hintItems.forEach(item => {
                    const hint = item.dataset.hint;
                    if (!isHintValid(hint)) {
                        // ì´ë¯¸ ì°¾ì€ ì§€ë¢°ì— ëŒ€í•œ íŒíŠ¸ëŠ” ì¤„ì„ ê·¸ì–´ì„œ í‘œì‹œ
                        if (!item.classList.contains('completed-hint')) {
                            item.classList.add('completed-hint');
                            item.style.opacity = '0.6';
                            item.style.textDecoration = 'line-through';
                            item.style.textDecorationThickness = '2px';
                            item.style.textDecorationColor = '#999';
                        }
                    }
                });
            }
            
            // ë¡œê·¸ ì¶”ê°€ (ì œê±°ë¨ - íŒíŠ¸ë§Œ í‘œì‹œ)
            function addLog(msg, type = '') {
                // ê²Œì„ ë¡œê·¸ëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
            }
            
            // ê²Œì„ ì‹œì‘
            function startGame() {
                // 2ë‹¨ê³„ì—ì„œëŠ” ê²Œì„ ì„¤ëª… íŒì—… í‘œì‹œ ì•ˆ í•¨
                
                // state ì™„ì „ ì´ˆê¸°í™” (stage1ê³¼ì˜ ì—°ë™ì„± ì™„ì „ ì œê±°)
                state.started = true;
                state.startTime = Date.now();
                state.mines.clear(); // ì§€ë¢° ì´ˆê¸°í™”
                state.tried.clear();
                state.hits.clear();
                state.score = 0;
                state.tries = 0;
                state.found = 0;
                state.currentHint = null;
                state.shownHints.clear();
                state.firstHintShown = false;
                state.lastHintTries = -1;
                state.stage2K = null;
                state.stage2KInv = null;
                
                // ê¸°ì¡´ ë¯¸ë¦¬ë³´ê¸° ì™„ì „ ì œê±° (stage1ê³¼ì˜ ì—°ë™ì„± ì œê±°)
                if (elements.minesPreview) {
                    elements.minesPreview.remove();
                    elements.minesPreview = null;
                }
                // DOMì—ì„œë„ ëª¨ë“  ë¯¸ë¦¬ë³´ê¸° ì œê±°
                const existingPreviews = document.querySelectorAll('#minesPreview');
                existingPreviews.forEach(preview => preview.remove());
                
                // placeMines()ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ì— ì´ˆê¸°í™” (placeMines()ì—ì„œ stage2Kì™€ stage2KInvë¥¼ ì„¤ì •í•¨)
                placeMines();
                elements.marks.innerHTML = '';
                elements.lines.innerHTML = '';
                elements.autoHintsList.innerHTML = '';
                elements.inputError.classList.remove('show');
                
                elements.startBtn.disabled = true;
                elements.resetBtn.disabled = false;
                elements.input.disabled = false;
                elements.submitBtn.disabled = false;
                
                // 2ë‹¨ê³„ì—ì„œëŠ” placeholder ì„¤ì •
                    elements.input.placeholder = '(x,y) ë˜ëŠ” y = kx ë˜ëŠ” y = k/x';
                
                elements.input.focus();
                
                // ê²Œì„ ì‹œì‘ ë©”ì‹œì§€ëŠ” íŒíŠ¸ë¡œ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                
                updateUI();
                
                // 2ë‹¨ê³„ì—ì„œ ì²« ë²ˆì§¸ íŒíŠ¸ ìë™ í‘œì‹œ
                if (!state.firstHintShown) {
                    const firstHint = 'ì§€ë¢°ëŠ” í•˜ë‚˜ì˜ ì •ë¹„ë¡€ ê´€ê³„ ê·¸ë˜í”„ ìœ„ì— 2ê°œ, í•˜ë‚˜ì˜ ë°˜ë¹„ë¡€ ê·¸ë˜í”„ ìœ„ì— 2ê°œ ìˆë‹¤.';
                    state.firstHintShown = true;
                    state.currentHint = firstHint;
                    state.shownHints.add(firstHint); // íŒíŠ¸ ì¤‘ë³µ ë°©ì§€
                    showAutoHintPopup(firstHint);
                    addAutoHint(firstHint);
                }
            }
            
            // ê²Œì„ ë¦¬ì…‹
            function resetGame() {
                state.started = false;
                state.mines.clear();
                state.tried.clear();
                state.hits.clear();
                state.score = 0;
                state.tries = 0;
                state.found = 0;
                state.currentHint = null;
                state.shownHints.clear();
                // currentStageëŠ” 2ë‹¨ê³„ë¡œ ê³ ì •
                state.totalScore = 0;
                state.stage2K = null;
                state.stage2KInv = null;
                state.firstHintShown = false;
                state.lastHintTries = -1;
                
                // ê²Œì„ ì¢…ë£Œ ì˜¤ë²„ë ˆì´ ì œê±°
                const existingOverlay = document.querySelector('.game-over-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                elements.marks.innerHTML = '';
                elements.lines.innerHTML = '';
                elements.autoHintsList.innerHTML = '';
                elements.inputError.classList.remove('show');
                
                // ë¯¸ë¦¬ë³´ê¸° ì œê±°
                if (elements.minesPreview) {
                    elements.minesPreview.remove();
                    elements.minesPreview = null;
                }
                
                elements.startBtn.disabled = false;
                elements.resetBtn.disabled = true;
                elements.input.disabled = true;
                elements.submitBtn.disabled = true;
                elements.input.value = '';
                
                updateUI();
                updateMineDisplay();
            }
            
            // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰ (stage2ì—ì„œëŠ” stage3.htmlë¡œ ì´ë™)
            function nextStage() {
                // stage3.htmlë¡œ ì´ë™
                window.location.href = 'stage3.html';
            }
            
            // ê²Œì„ ì¢…ë£Œ
            function endGame() {
                const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                
                // í˜„ì¬ ë‹¨ê³„ ì ìˆ˜ë¥¼ ì „ì²´ ì ìˆ˜ì— ì¶”ê°€
                state.totalScore += state.score;
                
                // localStorageì— 2ë‹¨ê³„ ì ìˆ˜ ì €ì¥
                localStorage.setItem('game_stage2_score', state.score.toString());
                
                setTimeout(() => {
                    // ê¸°ì¡´ ê²Œì„ ì¢…ë£Œ ì˜¤ë²„ë ˆì´ ì œê±°
                    const existingOverlay = document.querySelector('.game-over-overlay');
                    if (existingOverlay) {
                        existingOverlay.remove();
                    }
                    
                    // ê²Œì„ ì¢…ë£Œ ì˜¤ë²„ë ˆì´ ìƒì„±
                    const overlay = document.createElement('div');
                    overlay.className = 'game-over-overlay';
                    
                    const gameOverDiv = document.createElement('div');
                    gameOverDiv.className = 'game-over';
                    
                    const title = document.createElement('h2');
                    if (state.currentStage === 3) {
                        // ëª¨ë“  ë‹¨ê³„ ì™„ë£Œ
                        title.appendChild(document.createTextNode('ì¶•í•˜í•©ë‹ˆë‹¤!'));
                        const br1 = document.createElement('br');
                        title.appendChild(br1);
                        title.appendChild(document.createTextNode('ëª¨ë“  ë‹¨ê³„ë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤!ğŸ‘‘'));
                    } else {
                        // 2ë‹¨ê³„ ì™„ë£Œ
                        title.appendChild(document.createTextNode('ğŸŒŸ2ë‹¨ê³„ ì„±ê³µğŸŒŸ'));
                    }
                    
                    const triesP = document.createElement('p');
                    triesP.textContent = `ì´ ì‹œë„: ${state.tries}íšŒ`;
                    
                    const scoreP = document.createElement('p');
                    scoreP.textContent = `2ë‹¨ê³„ ì ìˆ˜: ${state.score}ì `;
                    
                    // ì „ì²´ ì ìˆ˜ëŠ” 3ë‹¨ê³„ì—ì„œë§Œ í‘œì‹œ (2ë‹¨ê³„ì—ì„œëŠ” í‘œì‹œ ì•ˆ í•¨)
                    let totalScoreP = null;
                    if (false) {
                        totalScoreP = document.createElement('p');
                        totalScoreP.textContent = `ì „ì²´ ì ìˆ˜: ${state.totalScore}ì `;
                        totalScoreP.style.fontWeight = 'bold';
                        totalScoreP.style.color = '#667eea';
                    }
                    
                    const timeP = document.createElement('p');
                    timeP.textContent = `ì†Œìš” ì‹œê°„: ${minutes}ë¶„ ${seconds}ì´ˆ`;
                    
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center; margin-top: 20px;';
                    
                    // ë‹¤ìŒ ë‹¨ê³„ ë²„íŠ¼ (2ë‹¨ê³„ì—ì„œëŠ” í•­ìƒ í‘œì‹œ)
                        const nextStageBtn = document.createElement('button');
                        nextStageBtn.id = 'nextStageBtn';
                        nextStageBtn.textContent = 'ë‹¤ìŒ ë‹¨ê³„ë¡œ';
                        nextStageBtn.style.cssText = 'padding: 12px 30px; font-size: 18px; background: #28a745;';
                        nextStageBtn.addEventListener('click', () => {
                            overlay.remove();
                            nextStage();
                        });
                        buttonContainer.appendChild(nextStageBtn);
                    
                    const restartBtn = document.createElement('button');
                    restartBtn.id = 'restartAfterWin';
                    restartBtn.textContent = 'ê²Œì„ ë‹¤ì‹œ ì‹œì‘';
                    restartBtn.addEventListener('click', () => {
                        overlay.remove();
                        resetGame();
                    });
                    buttonContainer.appendChild(restartBtn);
                    
                    gameOverDiv.appendChild(title);
                    gameOverDiv.appendChild(triesP);
                    gameOverDiv.appendChild(scoreP);
                    if (totalScoreP) {
                        gameOverDiv.appendChild(totalScoreP);
                    }
                    gameOverDiv.appendChild(timeP);
                    gameOverDiv.appendChild(buttonContainer);
                    overlay.appendChild(gameOverDiv);
                    document.body.appendChild(overlay);
                }, 500);
            }
            
            // ì…ë ¥ ì²˜ë¦¬
            function handleSubmit() {
                if (!state.started) return;
                
                const input = elements.input.value.trim();
                if (!input) return;
                
                const parsed = parseInput(input);
                
                if (parsed.type === 'error') {
                    elements.inputError.classList.add('show');
                    elements.input.value = '';
                    elements.input.focus();
                    return;
                }
                
                if (parsed.type === 'point') {
                    checkPoint(parsed.x, parsed.y);
                    elements.inputError.classList.remove('show');
                } else if (parsed.type === 'proportional') {
                    scanProportional(parsed.k);
                    elements.inputError.classList.remove('show');
                } else if (parsed.type === 'inverse') {
                    scanInverse(parsed.k);
                    elements.inputError.classList.remove('show');
                } else if (parsed.type === 'error') {
                    // ëª¨ë“  ë‹¨ê³„ì—ì„œ ì—ëŸ¬ í‘œì‹œ
                    elements.inputError.classList.add('show');
                }
                
                elements.input.value = '';
                elements.input.focus();
            }
            
            // ì´ë²¤íŠ¸ ë°”ì¸ë”©
            elements.startBtn.addEventListener('click', startGame);
            elements.resetBtn.addEventListener('click', resetGame);
            elements.submitBtn.addEventListener('click', handleSubmit);
            elements.input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSubmit();
            });
            
            // ì´ë²¤íŠ¸ ë°”ì¸ë”©ì€ ì´ë¯¸ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì „ì—­ ë…¸ì¶œ ë¶ˆí•„ìš”
            
            // ì´ˆê¸°í™”
            // stage2.html ë¡œë“œ ì‹œ ì™„ì „íˆ ì´ˆê¸°í™” (stage1ê³¼ì˜ ì—°ë™ì„± ì œê±°)
            state.mines.clear();
            state.tried.clear();
            state.hits.clear();
            state.score = 0;
            state.tries = 0;
            state.found = 0;
            state.started = false;
            state.startTime = null;
            state.currentHint = null;
            state.shownHints.clear();
            state.firstHintShown = false;
            state.lastHintTries = -1;
            state.stage2K = null;
            state.stage2KInv = null;
            
            // ê¸°ì¡´ ë¯¸ë¦¬ë³´ê¸° ì™„ì „ ì œê±°
            if (elements.minesPreview) {
                elements.minesPreview.remove();
                elements.minesPreview = null;
            }
            // DOMì—ì„œë„ ëª¨ë“  ë¯¸ë¦¬ë³´ê¸° ì œê±°
            const existingPreviews = document.querySelectorAll('#minesPreview');
            existingPreviews.forEach(preview => preview.remove());
            
            drawGrid();
            drawAxes();
            updateUI();
            updateStageIndicator();
        })();
    </script>
</body>
</html>